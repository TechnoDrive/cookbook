<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>The Cookbook</title>
        <meta name="robots" content="noindex">


    <!-- Custom HTML head -->

    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <!-- Provide site root to javascript -->
    <script>
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>
    <!-- Start loading toc.js asap -->
    <script src="toc.js"></script>
</head>
<body>
<div id="body-container">
    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script>
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) {
        }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script>
        var theme;
        try {
            theme = localStorage.getItem('mdbook-theme');
        } catch (e) {
        }
        if (theme === null || theme === undefined) {
            theme = default_theme;
        }
        const html = document.documentElement;
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add("js");
    </script>

    <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

    <!-- Hide / unhide sidebar before it is displayed -->
    <script>
        var sidebar = null;
        var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
        if (document.body.clientWidth >= 1080) {
            try {
                sidebar = localStorage.getItem('mdbook-sidebar');
            } catch (e) {
            }
            sidebar = sidebar || 'visible';
        } else {
            sidebar = 'hidden';
        }
        sidebar_toggle.checked = sidebar === 'visible';
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <!-- populated by js -->
        <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
        <noscript>
            <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
        </noscript>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle">
            <div class="sidebar-resize-indicator"></div>
        </div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky">
                <div class="left-buttons">
                    <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor"
                           title="Toggle Table of Contents" aria-label="Toggle Table of Contents"
                           aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </label>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none">
                            <button role="menuitem" class="theme" id="light">Light</button>
                        </li>
                        <li role="none">
                            <button role="menuitem" class="theme" id="rust">Rust</button>
                        </li>
                        <li role="none">
                            <button role="menuitem" class="theme" id="coal">Coal</button>
                        </li>
                        <li role="none">
                            <button role="menuitem" class="theme" id="navy">Navy</button>
                        </li>
                        <li role="none">
                            <button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                                aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                                aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                </div>

                <h1 class="menu-title">The Cookbook</h1>

                <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dr-hextanium/cookbook/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                </div>
            </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                               aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script>
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <h1 id="introduction"><a class="header" href="#introduction">introduction</a></h1>
<p>Welcome to the Cookbook. Enjoy your stay :)</p>
<p>The Cookbook is essentially a "handbook" maintained by the community for common (or not) issues that people have faced. The original motivation for this was to better prepare my team (4017) for when I left, since we've gained so much knowledge over just a single year that may eventually be lost. Throughout our region, I have seen many teams be completely lost after a great programmer or designer leaves, because they were simply not taught.</p>
<p>While a list of problems and solutions is not "teaching one how to fish", it serves as an incredibly helpful guide to just get things working. I hope by making my lil' cookbook open source, <strong>everyone</strong> can both use and build on my limited knowledge base.</p>
<p>If you (or anyone) has a problem, I'd love if you could make a lil' "recipe" and help anyone else in the future :)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tags"><a class="header" href="#tags">Tags</a></h1>
<p>Cookbook includes a set of quick aliases to many of the articles.
These can be easily accessed using tools like Carl custom tags.
One is available here: https://carl.gg/t/2167631</p>
<p>Here is a list of all of them:</p>
<p>!cb tags -&gt; this page</p>
<p>!cb help -&gt; this page</p>
<p>!cb as -&gt; https://cookbook.dairy.foundation/intro_to_programming/setup.html</p>
<p>!cb git -&gt; https://cookbook.dairy.foundation/intro_to_programming/intro_to_git.html</p>
<p>!cb jdk -&gt; https://cookbook.dairy.foundation/gradle/downgrading_gradle_jdk/downgrading_gradle_jdk.html</p>
<p>!cb gradle -&gt; https://cookbook.dairy.foundation/gradle/dont_upgrade/dont_upgrade.html</p>
<p>!cb emptylist -&gt; https://cookbook.dairy.foundation/roadrunner_10/null_list_error_in_rr_10.html</p>
<p>!cb builder -&gt; https://cookbook.dairy.foundation/roadrunner_10/complete_trajectorybuilder_reference.html</p>
<p>!cb bump -&gt; https://cookbook.dairy.foundation/roadrunner_056/is_the_bump_on_manual_feedforward_tuner_normal.html</p>
<p>!cb ffbump -&gt; https://cookbook.dairy.foundation/roadrunner_056/is_the_bump_on_manual_feedforward_tuner_normal.html</p>
<p>!cb overshoot -&gt; https://cookbook.dairy.foundation/roadrunner_056/is_the_bump_on_manual_feedforward_tuner_normal.html</p>
<p>!cb null -&gt; https://cookbook.dairy.foundation/common_ds_errors/npe_at_init/npe_at_init.html</p>
<p>!cb npe -&gt; https://cookbook.dairy.foundation/common_ds_errors/npe_at_init/npe_at_init.html</p>
<p>!cb pid -&gt; https://cookbook.dairy.foundation/pidf_controllers/integrating_a_custom_PIDF_controller.html</p>
<p>!cb pidsync -&gt; https://cookbook.dairy.foundation/pidf_controllers/syncing_two_linear_slide_motors_using_a_pidf_controller/syncing_two_linear_slide_motors_using_a_pidf_controller.html</p>
<p>!cb usb -&gt; https://cookbook.dairy.foundation/electrical/why_we_should_only_use_usb_30.html</p>
<p>!cb usb3 -&gt; https://cookbook.dairy.foundation/electrical/why_we_should_only_use_usb_30.html</p>
<p>!cb odo -&gt; https://cookbook.dairy.foundation/electrical/how_to_wire_odometry_pods.html</p>
<p>!cb kotlin -&gt; https://cookbook.dairy.foundation/misc/why_kotlin/why_kotlin.html</p>
<p>!cb loop -&gt; https://cookbook.dairy.foundation/improving_loop_times/improving_loop_times.html</p>
<p>!cb looptimes -&gt; https://cookbook.dairy.foundation/improving_loop_times/improving_loop_times.html</p>
<p>!cb pedrovsrr -&gt; https://cookbook.dairy.foundation/misc/pedro_vs_roadrunner.html</p>
<p>!cb rrvspedro -&gt; https://cookbook.dairy.foundation/misc/pedro_vs_roadrunner.html</p>
<p>!cb tab -&gt; https://cookbook.dairy.foundation/roadrunner_10/complete_trajectorybuilder_reference.html</p>
<p>!cb trajectory -&gt; https://cookbook.dairy.foundation/roadrunner_10/complete_trajectorybuilder_reference.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-environment-setup"><a class="header" href="#development-environment-setup">Development Environment Setup</a></h1>
<p>This is a guide designed to assist new FTC programmers setup the <a href="https://developer.android.com/studio/">Android Studio</a> environment to program a robot.</p>
<h2 id="ingredients"><a class="header" href="#ingredients">Ingredients</a></h2>
<p>A <strong>Computer</strong> that has the <a href="https://developer.android.com/studio/install">required specs</a> for <a href="https://developer.android.com/studio/">Android Studio</a> and installing <a href="https://www.oracle.com/java/technologies/downloads/">Java</a>. <br>
Access to <strong>Admin Permissions</strong> on aforementioned computer.<br></p>
<h2 id="software-to-be-installed"><a class="header" href="#software-to-be-installed">Software to be Installed</a></h2>
<p><strong>FTC SDK</strong>: <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController">FtcRobotController</a><br>
<strong>IDE</strong>: <a href="https://developer.android.com/studio/">Android Studio</a><br>
<strong>Java</strong>: Any recent version of <a href="https://www.oracle.com/java/technologies/downloads/">Java</a><br>
<strong>ADB</strong>: <a href="https://developer.android.com/tools/releases/platform-tools">Android Debug Bridge</a><br></p>
<h2 id="recipe-installation"><a class="header" href="#recipe-installation">Recipe (Installation)</a></h2>
<ol>
<li><strong>Download and Install <a href="https://www.oracle.com/java/technologies/downloads/">Java</a></strong>:
<strong><br>NOTE: Installing <a href="https://www.oracle.com/java/technologies/downloads/">Java</a> may require Admin Permissions.</strong>
<ul>
<li>Download the latest version of <a href="https://www.oracle.com/java/technologies/downloads/">Java</a>.</li>
<li>Run the installer and follow the on-screen instructions. <br>
<br></li>
</ul>
</li>
<li><strong>Download and Install <a href="https://developer.android.com/studio/">Android Studio</a></strong>:
<strong><br>NOTE: Installing <a href="https://developer.android.com/studio/">Android Studio</a> may require Admin Permissions.</strong>
<ul>
<li>Download the latest version of <a href="https://developer.android.com/studio/">Android Studio</a>.</li>
<li>Run the installer and follow the on-screen instructions.</li>
<li>Open <a href="https://developer.android.com/studio/">Android Studio</a>. <br>
<br></li>
</ul>
</li>
<li><strong>Download and Open <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController">FtcRobotController</a></strong>:
<ul>
<li>In the <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController">FtcRobotController</a> GitHub repository, press the blue <strong>code</strong> button and press <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController/archive/refs/heads/master.zip">download zip</a>.
<ul>
<li>You can alternatively use <a href="https://desktop.github.com/">Github Desktop</a> to open <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController">FtcRobotController</a> in <a href="https://developer.android.com/studio/">Android Studio</a>, which is not covered in this Recipe.</li>
</ul>
</li>
<li>Extract the contents of the zip file to a folder (typically in your Downloads or Documents folder).</li>
<li>In <a href="https://developer.android.com/studio/">Android Studio</a>, press File â†’ Open (âŒ˜ + O on Mac or Win + O on Windows).</li>
<li>Select the folder you extracted the zip file to, and press open. <strong>DO NOT</strong> open any folder inside the extracted folder.
<ul>
<li>On MacOS, you can alternatively drag the folder from Finder onto the <a href="https://developer.android.com/studio/">Android Studio</a> icon in your taskbar to open the folder.</li>
</ul>
</li>
<li>Wait for the project to load. You should end up with 3 folders in the Android view panel (which you should automatically be moved to once ready): <strong>FtcRobotController</strong>, <strong>TeamCode</strong>, and <strong>Gradle Scripts</strong>. <br>
<br></li>
</ul>
</li>
<li><strong>Install</strong> <a href="https://developer.android.com/studio/releases/platform-tools"><strong>ADB</strong></a>:
<strong><br>NOTE: Installing <a href="https://developer.android.com/studio/releases/platform-tools">ADB</a> may require Admin Permissions.</strong>
<ul>
<li>Download the latest version of <a href="https://developer.android.com/studio/releases/platform-tools">ADB</a>.
Press on one of the three links depending on your operating system.</li>
<li>Extract the contents of the zip file to a folder (typically in your Downloads or Documents folder).</li>
<li>Add the folder to your system's PATH variable:
<ul>
<li><strong>Windows</strong>:
<ul>
<li>Open the start menu and search for "Environment Variables", and press enter.</li>
<li>Click on "Edit the system environment variables".</li>
<li>Click on "Environment Variables".</li>
<li>In the "System variables" section, find the "Path" variable and click "Edit".</li>
<li>Click "New" and paste the path to the folder where you extracted the zip file.</li>
<li>Click "OK" on all the windows.</li>
</ul>
</li>
<li><strong>Mac</strong>: <br>
<ul>
<li>
<p>Option 1 - Using <a href="https://brew.sh/">Homebrew</a> (Highly Recommended) <br>
<a href="https://brew.sh/">Homebrew</a> is a package manager for Mac. This is the easiest way and will provide automatic updates.</p>
<ul>
<li>Install the <a href="https://brew.sh/">Homebrew</a> package manager by running the following command in a terminal:</li>
</ul>
<pre><code class="language-bash">/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"
</code></pre>
<ul>
<li>Then, run this command to install <a href="https://developer.android.com/studio/releases/platform-tools">ADB</a> using <a href="https://brew.sh/">Homebrew</a>:</li>
</ul>
<pre><code class="language-bash">brew install android-platform-tools
</code></pre>
</li>
<li>
<p>Option 2 - Manual Installation</p>
<ul>
<li>Go to your Downloads folder with this command in terminal:</li>
</ul>
<pre><code class="language-bash">cd ~/Downloads/
</code></pre>
<ul>
<li>Then, to avoid deleting the ADB files, move the downloaded file to a new folder (the commands below should still work with modern versions of MacOS):</li>
</ul>
<pre><code class="language-bash">mkdir ~/.android-sdk-macosx
mv platform-tools/ ~/.android-sdk-macosx/platform-tools
</code></pre>
<ul>
<li>Add <code>platform-tools</code> to your path</li>
</ul>
<pre><code class="language-bash">echo 'export PATH=$PATH:~/.android-sdk-macosx/platform-tools/' &gt;&gt; ~/.bash_profile
</code></pre>
<ul>
<li>Reload your terminal profile (or restart your terminal):</li>
</ul>
<pre><code class="language-bash">source ~/.bash_profile
</code></pre>
</li>
</ul>
</li>
<li><strong>Linux</strong>:
<br><a href="https://developer.android.com/studio/releases/platform-tools">ADB</a> should already be installed by default with the installation of Android Studio. If not, you can use the following steps below to install <a href="https://developer.android.com/studio/releases/platform-tools">ADB</a> manually:<br>
<br>
<ul>
<li>Open a terminal window and run the following command:
<pre><code class="language-bash">nano ~/.bashrc
</code></pre>
<ul>
<li>Add the following line to the file:</li>
</ul>
<pre><code class="language-bash">export PATH=$PATH:/path/to/adb/folder
</code></pre>
<ul>
<li>Press <code>Ctrl + X</code>, then <code>Y</code>, then <code>Enter</code> to save the file.</li>
<li>Run the following command:</li>
</ul>
<pre><code class="language-bash">source ~/.bashrc
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>Finally, to check that your properly installed <a href="https://developer.android.com/studio/releases/platform-tools">ADB</a>, in the Android Studio Terminal (Control + F12 on Windows or âŒ˜ + F12 on Mac), or on your default/preferred terminal, run the following command:</li>
</ul>
<pre><code class="language-bash">adb devices
</code></pre>
<ul>
<li>If you see a message saying <code>List of devices attached</code>, you have successfully installed ADB (even if there are no devices attached).</li>
</ul>
</li>
</ol>
<p>Congratulations! You have successfully installed the necessary software to program an FTC robot. You can now start programming your robot.</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<ul>
<li>If you have questions/issues with the installation process, the <a href="https://discord.gg/first-tech-challenge">Unofficial FTC Discord</a> has many experienced programmers who can help you with all sorts of issues, including installation issues.</li>
<li><em>Last Updated: 2024-05-30</em></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-git-and-github"><a class="header" href="#introduction-to-git-and-github">Introduction to Git and GitHub</a></h1>
<p>This guide is designed to help FTC teams understand how to use Git and GitHub to track changes,
collaborate better, and recover previous versions.
There are often multiple ways to achieve the same task when using Git,
so this guide will explain the method we think is the easiest.</p>
<p>This guide also assumes you are using the base FIRST Tech Challenge SDK.
If you are instead using the RoadRunner quickstart or similar, use that in place of the SDK.</p>
<h3 id="git-vs-github"><a class="header" href="#git-vs-github">Git vs GitHub</a></h3>
<p><strong>Git</strong> is a version control system that tracks changes in code over time, allowing you to collaborate effectively.
<strong>GitHub</strong> is a platform that hosts Git repositories.
Though there are many Git hosting platforms, including GitLab and Bitbucket,
this guide focuses on GitHub because it is the easiest to use with the FTC SDK.</p>
<h2 id="ingredients-1"><a class="header" href="#ingredients-1">Ingredients</a></h2>
<ol>
<li>Internet access</li>
<li>A computer</li>
<li>Android Studio</li>
<li>A <a href="https://github.com/">GitHub</a> account and organization.
<ul>
<li>To create an account, follow the steps on <a href="https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github">GitHub</a>.</li>
<li>While creating an organization is optional, it is highly recommended for FTC teams.
Follow the directions on <a href="https://docs.github.com/en/organizations/collaborating-with-groups-in-organizations/creating-a-new-organization-from-scratch">GitHub</a>.</li>
<li>Note that user accounts can only create one fork of a repository, while organization accounts can create multiple.
This makes it easier for your team to set up a repository for each season.</li>
</ul>
</li>
</ol>
<h2 id="recipe"><a class="header" href="#recipe">Recipe</a></h2>
<h3 id="0-installing-git"><a class="header" href="#0-installing-git">0. Installing Git</a></h3>
<p>The easiest way to install Git on your device is
to download it from <a href="https://git-scm.com/downloads">Git's download page</a>.
Select your operating system and follow the instructions on the website.</p>
<h3 id="1-forking-the-repository"><a class="header" href="#1-forking-the-repository">1. Forking the Repository</a></h3>
<p>This step only needs to be done once each season.</p>
<blockquote>
<p>A Fork on GitHub is a copy of another repository on GitHub from one account to another account.
The new forked repository retains a parent-child relationship with the origin repository.
Forks are typically used when software will have an independent line of development,
such as when FTC teams develop their own team code
using the FIRST-Tech-Challenge/FtcRobotController repository as a basis.
FTC teams should create a Fork of the FIRST-Tech-Challenge/FtcRobotController repository as a convenient way
to manage their software development process.
Thanks to the parent-child relationship,
when changes are made to the parent repository
those changes can be easily tracked and fetched/merged into the forked repository,
keeping the forked repository up to date.</p>
</blockquote>
<ul>
<li>The FIRST Tech Challenge documentation</li>
</ul>
<p>First, open the <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController">FtcRobotController repository</a>.
The FtcRobotController repo is the Software Development Kit (SDK)
provided by FIRST that allows you to write your own robot code.</p>
<p>Once you have opened the repo, click the <code>Fork</code> button in the upper-right-hand corner.
That will bring you to a page that looks like this:</p>
<p><img src="intro_to_programming/../static/intro_to_git/fork.png" alt="The fork page" /></p>
<p>Under the <code>Owner</code> dropdown, select your organization (if you elected to create one),
as opposed to your individual user account.
Under <code>Repository name</code>, I recommend naming your repo after the current FTC season name
(such as Into The Deep or CenterStage), or by the year (such as 2024).
Finally, press <code>Create fork</code> to create your own copy of the SDK repository.</p>
<h4 id="15-logging-into-github-on-android-studio"><a class="header" href="#15-logging-into-github-on-android-studio">1.5 Logging into GitHub on Android Studio</a></h4>
<p>First, open your <a href="https://github.com/settings/tokens">GitHub token settings</a>,
either by clicking on that link or by going to Account Settings â†’ Developer Settings â†’ Tokens (Classic).
Press <code>Generate new token (classic)</code> at the top and that will take you to a page that looks like this:</p>
<p><img src="intro_to_programming/../static/intro_to_git/personal_access_token.png" alt="The token generation page" /></p>
<p>For <code>Note</code>, write the use case of the token, such as "Android Studio."
For <code>Expiration</code>, select <code>No expiration</code>, which may cause GitHub to warn you.
For <code>Select scopes</code>, select <code>repo</code>, <code>workflow</code>, <code>read:org</code>, and <code>gist</code>.
Finally, click <code>Generate token</code> and copy it.</p>
<p>Now open Android Studio.
Open your settings (under <code>File</code> then <code>Settings</code>)
and then go to <code>Version Control</code> -&gt; <code>GitHub</code>.
In the top left corner of the box, press the <code>+</code> icon and <code>Log in with token...</code>,
and paste in the token you just generated.</p>
<h3 id="2-opening-your-fork-in-android-studio"><a class="header" href="#2-opening-your-fork-in-android-studio">2. Opening Your Fork in Android Studio</a></h3>
<p>This step needs to be done by everyone who intends on programming for your team.</p>
<p>First, at the top right of your new repository, press the green <code>Code</code> button.
Under that tab, copy the HTTP url of your repo.</p>
<p>Next, open Android Studio and navigate to the <code>New Project from Version Control</code> menu.
To do that, do <code>File</code> -&gt; <code>New</code> -&gt; <code>Project from Version Control</code>, which should bring you to a menu that looks like this:</p>
<p><img src="intro_to_programming/../static/intro_to_git/get_from_vcs.png" alt="Get from VCS menu" /></p>
<p>For the URL, paste in the link that you just copied from your repo, then press <code>Clone</code>.
Android Studio will then download your project and build it through Gradle, which may take a few minutes;
you can monitor this process using the progress bar in the bottom right.</p>
<p>Once this is complete, your project is ready to use,
and you can start coding as normal.</p>
<h3 id="3-your-first-commit"><a class="header" href="#3-your-first-commit">3. Your First Commit</a></h3>
<p>Now that you've made some changes,
you should create a <em>commit</em> to snapshot your changes and <em>push</em> (upload) them to GitHub.
To do this, press the button on the left side that looks like a line with a circle on it
(just like the circles in the above image) to open the Commit menu in Android Studio.
That will look like this:</p>
<p><img src="intro_to_programming/../static/intro_to_git/commit%20menu.png" alt="The commit menu" /></p>
<p>The <code>Changes</code> section will show the files you have edited.
Select the files you want to commit by clicking on the checkbox next to them,
or use the checkbox in the top left to select all of them.</p>
<p>Finally, write a commit message in the box in the lower portion of the menu to describe what you've changed.
In this example, I added a <code>MecanumChassis</code> wrapper and edited some other files,
so that's what I wrote in my commit message.</p>
<p>Once you're done,
press <code>Commit and Push...</code> which will commit your changes and push them to GitHub's copy of your repository.</p>
<p>In some situations (such as when you are offline, or when a push fails),
you may also prefer to just hit the <code>Commit</code> button to save an offline snapshot of your changes,
and then later click your branch title in the top right, which displays the following options:</p>
<p><img src="intro_to_programming/../static/intro_to_git/push_button.png" alt="The push icon" /></p>
<p>Click <code>Push...</code>, and then <code>Push</code> in the bottom right of the menu that comes up after that.</p>
<h3 id="4-pulling-from-github"><a class="header" href="#4-pulling-from-github">4. Pulling from GitHub</a></h3>
<p>Once one person has committed a change,
the other programmers on your team will want to download or <em>pull</em> those changes from GitHub.
To do this, click on your branch and then the <code>Update Project</code> icon or button in the top left, as shown below:</p>
<p><img src="intro_to_programming/../static/intro_to_git/update_project.png" alt="The pull icon" /></p>
<p>This will ask you whether you want to Merge or to Rebase the incoming changes.
Merging is simpler, so we will explain it here; select it and hit OK.</p>
<p>Most of the time that will be all that is necessary to download all the incoming changes, and
you will immediately be able to resume coding.
However, occasionally when multiple people edit the same file at the same time, a Merge Conflict can occur.
This can appear as a Conflict pop up as shown below.</p>
<p><img src="intro_to_programming/../static/intro_to_git/merge_conflicts_dialog_dark.png" alt="The Conflict pop up" /></p>
<p>See the <a href="https://www.jetbrains.com/help/idea/resolve-conflicts.html">official JetBrains documentation</a>
for what to do in this scenario.
Make sure to commit after the merge is complete.</p>
<h2 id="additional-features"><a class="header" href="#additional-features">Additional Features</a></h2>
<h3 id="updating-from-the-first-sdk"><a class="header" href="#updating-from-the-first-sdk">Updating from the FIRST SDK</a></h3>
<p>Throughout the season, the FIRST SDK sometimes updates to new versions.
To incorporate these changes into your codebase,
we need to add the SDK as a remote repository and then pull in its changes.</p>
<p>First, open a terminal using the button in the bottom left.</p>
<p>Next, the first time you update, run this command in the terminal:
<code>git remote add sdk https://github.com/FIRST-Tech-Challenge/FtcRobotController/</code>
This will add the FIRST SDK as a remote repository named <code>sdk</code>.
You will only have to do this once.</p>
<p>Next, each time you want to update, run this command: <code>git pull sdk master --no-rebase</code>
This will pull the changes from the <code>master</code> branch of the <code>sdk</code> remote repository.
We use <code>--no-rebase</code> here to ensure that we merge instead of rebasing.</p>
<p>Finally, make a new commit to incorporate the changes into your repository.
There will very likely be merge conflicts, review step 4 to learn how to deal with those.</p>
<h3 id="creating-branches"><a class="header" href="#creating-branches">Creating Branches</a></h3>
<p>A branch allows you to separate your codebase into multiple versions,
which can be developed individually and combined later.
Each branch can have its own set of commits.
In the following image, each circle represents a commit in the branch.</p>
<p><img src="intro_to_programming/../static/intro_to_git/branches.png" alt="Branches and Commits" /></p>
<p>Some teams prefer to create a new branch for each feature that they create.
To do that in AS, in the top menu to go <code>Git</code> -&gt; <code>New Branch</code>, and type in the name of that feature.
AS will automatically <em>checkout</em> that branch, meaning all future commits from your client will be to that branch.</p>
<h3 id="merging-branches"><a class="header" href="#merging-branches">Merging Branches</a></h3>
<p>To merge changes from one branch onto another through Android Studio, open the Git menu as shown below.</p>
<p><img src="intro_to_programming/../static/intro_to_git/git_menu.png" alt="Git menu" /></p>
<p>Now, right-click on the branch you intend on merging from and press <code>Merge origin/&lt;branch&gt; into &lt;branch&gt;</code>.
This will simply update those files in your local copy of the code with the changes from the other branch.
Note that this can also lead to Merge Conflicts as explained in step 4.
After the merge is complete, make sure to commit the new combined code.</p>
<p>It is also possible to merge changes online through GitHub using Pull Requests.
Pull Requests also allow others to easily review your changes.</p>
<p>At this point, we're going back to the GitHub website.
Open your repository and hit the <code>Pull Requests</code> tab in the top left,
which will open a page that looks somewhat like this:</p>
<p><img src="intro_to_programming/../static/intro_to_git/pull_request.png" alt="Pull requests" /></p>
<p>Make sure that both repositories are the same (your repo).
Then, for base, select <code>master</code>, and for <code>compare</code> select whatever branch you were working with.
Press <code>Create pull request</code> and type the name and description of the commit(s) you are working with,
and then press <code>Create pull request</code> again.</p>
<p>At this point, GitHub will automatically determine if there are merge conflicts.
See <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/addressing-merge-conflicts/resolving-a-merge-conflict-on-github">GitHub's official documentation</a>
for information on how to resolve them, if they occur.
Once any conflicts are resolved,
and you are ready to merge the branches (potentially after getting approval from your team),
select the <code>Merge pull request</code> button to accept the pull request.</p>
<p><em>Last updated: 2024-10-06</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="downgrading-the-gradle-jdk-on-android-studio-ladybug"><a class="header" href="#downgrading-the-gradle-jdk-on-android-studio-ladybug">Downgrading the Gradle JDK on Android Studio Ladybug</a></h1>
<p>From version Ladybug | 2024.2.1 of Android Studio (AS), the software ships with
Java 21 as the Gradle JDK.</p>
<div class="warning">
<p>Trying to build an SDK project of version <code>10.1.1</code> or later without being on
Android Studio Ladybug or later will not work.</p>
</div>
<p>This causes build issues for FTC projects on SDK versions before <code>10.1.1</code>.</p>
<p>The error looks like this:
<img src="gradle/downgrading_gradle_jdk/./failed_gradle_build.png" alt="erroring build" /></p>
<p>Although its tempting to press one of those magical blue links, this is a
horrible idea.</p>
<p>The correct fix here is to downgrade the Gradle JDK version to 17, which is
fairly easy to do.</p>
<p><img src="gradle/downgrading_gradle_jdk/./as_gradle_settings.png" alt="Android Studio Gradle settings menu" /></p>
<p>Select an option for Gradle JDK that is JDK version 17, and rebuild.</p>
<p>If you have no JDK 17 available, then you can click the download JDK option to
install JDK 17.</p>
<p>JDK 17 is a good choice as it will also support the new builds for <code>10.1.1</code>
onwards.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dont-upgrade-the-gradle-version-or-android-gradle-plugin-version"><a class="header" href="#dont-upgrade-the-gradle-version-or-android-gradle-plugin-version">Don't upgrade the Gradle version or Android Gradle Plugin version</a></h1>
<blockquote>
<p>Consider checking out <a href="gradle/dont_upgrade/../project_templates/project_templates.html">our article on alternate project
setups</a></p>
</blockquote>
<p>Android studio loves to tempt you with this little pop up, prompting you to
upgrade the Android Gradle Plugin (AGP).</p>
<p><img src="gradle/dont_upgrade/./upgrade_agp_message.png" alt="Android Studio upgrade AGP message" /></p>
<p>You need to click on [More] &gt; Don't show again for this project. This will
prevent the issue from occurring again.</p>
<p>These upgrades are not productive, and interfere with the current gradle build,
even if you get it working on your computer, it may cause issues with team
member's computers, and it makes it harder to upgrade the SDK when a new version
releases. Additionally, it may cause issues when working with other gradle
operations, like adding libraries.</p>
<p>If you accidentally upgrade the AGP or the Gradle version, you should hopefully
be able to use git to undo the change, or, you can override those files with
ones from the SDK.</p>
<p>It may be possible to undo the changes more simply by downgrading again.</p>
<blockquote>
<p>It may be easier to find these files with the file explorer set to <code>Project</code>
mode, rather than <code>Android</code> mode.
<img src="gradle/dont_upgrade/./as_file_explorer_modes.png" alt="AS file explorer modes" /></p>
</blockquote>
<h2 id="1011-onwards"><a class="header" href="#1011-onwards"><code>10.1.1</code> onwards</a></h2>
<p>The AGP version should be <code>8.7.0</code>. It is set in the project root <code>build.gradle</code>.
<img src="gradle/dont_upgrade/./agp_version%5BGTE10.1.1%5D.png" alt="AGP version" /></p>
<p>The Gradle version should be <code>8.9</code>. It is set in <code>gradle/wrapper/gradle-wrapper.properties</code>.
<img src="gradle/dont_upgrade/./gradle_wrapper_version%5BGTE10.1.1%5D.png" alt="Gradle version" /></p>
<h2 id="before-1011"><a class="header" href="#before-1011">Before <code>10.1.1</code></a></h2>
<p>The AGP version should be <code>7.2.0</code>. It is set in the project root <code>build.gradle</code>.
<img src="gradle/dont_upgrade/./agp_version%5BLT10.1.1%5D.png" alt="AGP version" /></p>
<p>The Gradle version should be <code>7.4.2</code>. It is set in <code>gradle/wrapper/gradle-wrapper.properties</code>.
<img src="gradle/dont_upgrade/./gradle_wrapper_version%5BLT10.1.1%5D.png" alt="Gradle version" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alternative-project-templates"><a class="header" href="#alternative-project-templates">Alternative Project Templates</a></h1>
<p>Dairy hosts a series of plugins and templates that use them in order to simplify
your TeamCode project structure.</p>
<p><a href="https://github.com/Dairy-Foundation/Templates/">Dairy-Foundation/Templates</a></p>
<p>Advantages:</p>
<ul>
<li>Gradle configuration is managed by a plugin, its easier to update the project
outside of gradle version changes.</li>
<li>Supports easily managing all of the SDK as one version.</li>
<li>Supports easily adding Kotlin support to your project.</li>
<li>Will support easily adding more FTC Libraries in the future.</li>
<li>Supports building Library modules along with TeamCode modules.</li>
<li>Simplified Project setup.</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li>Currently under documented.</li>
<li>Not the official SDK setup, which may be confusing for inexperienced team
members.</li>
<li>Needs more examples and templates for more complex setups.</li>
<li>Does not yet support many common FTC Libraries.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="null-list-error-in-road-runner-10"><a class="header" href="#null-list-error-in-road-runner-10">Null list error in Road Runner 1.0</a></h1>
<h3 id="ingredients-2"><a class="header" href="#ingredients-2">Ingredients</a></h3>
<ol>
<li>A Road Runner 1.0 setup</li>
<li>Completed ForwardPushTest and LateralPushTest</li>
</ol>
<h2 id="the-recipe"><a class="header" href="#the-recipe">The Recipe</a></h2>
<h3 id="the-problem"><a class="header" href="#the-problem">The problem</a></h3>
<p>If you have gotten through Road Runner 1.0 tuning to the ForwardRampLogger tuning step (you may also see this in LateralRampLogger or AngularRampLogger), sometimes you will get an empty list error when you press the "latest" button.</p>
<h3 id="solution"><a class="header" href="#solution">Solution</a></h3>
<p>You must first run the OpMode from the Driver Station and then stop it once the robot's speed stops increasing.
Finally, you can open the tuning page on your robot's Wi-Fi network, as the Road Runner docs say.</p>
<p><em>Last Updated: 2024-05-29</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="complete-trajectorybuilder-reference"><a class="header" href="#complete-trajectorybuilder-reference">Complete TrajectoryBuilder Reference</a></h1>
<h3 id="ingredients-3"><a class="header" href="#ingredients-3">Ingredients</a></h3>
<ol>
<li>A fully tuned <a href="https://rr.brott.dev/docs/">Road Runner 1.0</a> setup <em><strong>or</strong></em> <a href="https://github.com/acmerobotics/MeepMeep">MeepMeep for Road Runner 1.0</a></li>
</ol>
<h3 id="the-problem-1"><a class="header" href="#the-problem-1">The Problem</a></h3>
<p>The current <a href="https://rr.brott.dev/docs/v1-0/builder-ref/">TrajectoryBuilder Reference</a> in the official <a href="https://rr.brott.dev/docs/">Road Runner 1.0</a> docs only has a few TrajectoryBuilder methods, and does  not explain them very well in depth. This is a complete reference for more methods in the TrajectoryBuilder class for <a href="https://rr.brott.dev/docs/">Road Runner 1.0</a>.</p>
<hr />
<h2 id="trajectorybuilder-reference"><a class="header" href="#trajectorybuilder-reference">TrajectoryBuilder Reference</a></h2>
<h3 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h3>
<h4 id="path-primitives"><a class="header" href="#path-primitives"><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#path-primitives-1">Path Primitives:</a></a></h4>
<ol>
<li><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#waitsecondsdouble-seconds"><code>waitSeconds(double: seconds)</code></a></li>
<li><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#turnmathtoradiansdouble-angle"><code>turn(Math.toRadians(double: angle))</code></a></li>
<li><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#turntomathtoradiansdouble-heading"><code>turnTo(Math.toRadians(double: heading))</code></a></li>
<li><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#settangentdouble-r"><code>setTangent(double: r)</code></a></li>
<li><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#setreversedboolean-reversed"><code>setReversed(boolean: reversed)</code></a></li>
<li><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#strafetonew-vector2ddouble-x-double-y--strafetoconstantheadingnew-vector2dx-double-y-double"><code>.strafeTo(new Vector2d(double: x, double: y))</code> &amp; <code>.strafeToConstantHeading(new Vector2d(x: double, y: double))</code></a></li>
<li><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#strafetolinearheadingnew-vector2dx-y-mathtoradiansheading"><code>strafeToLinearHeading(new Vector2d(x, y), Math.toRadians(heading))</code></a></li>
<li><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#strafetosplineheadingnew-vector2dx-y-mathtoradiansheading"><code>strafeToSplineHeading(new Vector2d(x, y), Math.toRadians(heading))</code></a></li>
<li><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#linetoxx-double--linetoxconstantheadingx-double"><code>lineToX(x: double) &amp; .lineToXConstantHeading(x: double)</code></a></li>
<li><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#linetoyy-double--linetoyconstantheadingy-double"><code>lineToY(y: double) &amp; .lineToYConstantHeading(y: double)</code></a></li>
<li><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#splinetonew-vector2dx-y-tangent--heading-is--fracpi6-"><code>splineTo(new Vector2d(x, y), tangent)</code></a></li>
</ol>
<h4 id="heading-primitives"><a class="header" href="#heading-primitives"><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#heading-primitives-1">Heading Primitives:</a></a></h4>
<ol start="12">
<li><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#tangent-heading-default"><code>Tangent Heading (default)</code></a></li>
<li><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#constant-heading"><code>Constant Heading</code></a></li>
<li><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#linear-heading"><code>Linear Heading</code></a></li>
<li><a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#spline-heading"><code>Spline Heading</code></a></li>
</ol>
<h3 id="path-primitives-1"><a class="header" href="#path-primitives-1">Path Primitives</a></h3>
<p>The begin pose is the origin <code>(0,0)</code> with a heading of \( \frac{\pi}{6} \), with the exception of <a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html#splinetonew-vector2dx-y-tangent--heading-is--fracpi6-"><code>splineTo(new Vector2d(x, y), tangent)</code></a>, which has a heading of \( \frac{\pi}{2} \).</p>
<h4 id="waitsecondsdouble-seconds"><a class="header" href="#waitsecondsdouble-seconds"><code>waitSeconds(double: seconds)</code></a></h4>
<blockquote>
<p>ðŸš¨ <strong>WARNING:</strong> ðŸš¨<br />
Ensure that you are using <code>waitSeconds()</code> and not <code>wait()</code>. All Java objects have a <code>wait()</code> function which causes the current thread to wait until another thread invokes a <code>notify()</code> or <code>notifyAll()</code> method. See further details in the <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#wait()">Oracle JavaDoc</a>. We don't care for this function, but it does show up in intellisense. Make sure you are using the <code>waitSeconds()</code> function instead of <code>wait()</code>.</p>
</blockquote>
<pre><code class="language-java">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
// This is a simple wait segment that is useful for running actions in between trajectories.

.waitSeconds(5)
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise by the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
</span><span class="boring">// To turn clockwise, use a negative angle.
</span><span class="boring">
</span><span class="boring">.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
</span><span class="boring">.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise to the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// By default, the robot will turn in the shortest direction to the specified heading.
</span><span class="boring">// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
</span><span class="boring">// If it still does not work, you can use the `turn()` method instead.
</span><span class="boring">
</span><span class="boring">.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
</span><span class="boring">.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
</span><span class="boring">// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.
</span><span class="boring">
</span><span class="boring">.setTangent(90) // Sets tangent to 90
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
</span><span class="boring">// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
</span><span class="boring">// This can be fixed by reversing the path using `setReversed(true)`.
</span><span class="boring">
</span><span class="boring">.setReversed(false)  // Unreversed trajectory has hooks on the start and end
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
</span><span class="boring">// This means that:
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">// Is the same as:
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while maintaining its heading.
</span><span class="boring">// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
</span><span class="boring">// So, if you start at a 90 degree angle, it will keep that angle the entire path.
</span><span class="boring">
</span><span class="boring">.strafeTo(new Vector2d(48, -48))
</span><span class="boring">.strafeToConstantHeading(new Vector2d(48, -48))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToX(48)
</span><span class="boring">.lineToXConstantHeading(48)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToY(36)
</span><span class="boring">.lineToYConstantHeading(36)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while keeping the heading constant
</span><span class="boring">// The robot maintains the heading it starts at throughout the trajectory.
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<div class="video-container-1">
    <iframe width="505" height="650" 
        src="https://rr-playground-server.brott.dev/bcce1244-e518-4034-a384-6072fa7a491d.mp4?autoplay=0" title="waitSeconds()" style="border: none;" >
    </iframe>
</div>
<style>
.video-container-1 {
    display: flex;
    justify-content: center;
    width: 100%;
    overflow: hidden;
    margin: 0 auto;
    flex-wrap: wrap;
}

@media (max-width: 600px) {
    .video-container-1 {
        width: 328px;
        height: 423px;
    }
    
    .video-container-1 iframe {
        width: 328px;
        height: 423px;
    }
}
</style>
<hr />
<h4 id="turnmathtoradiansdouble-angle"><a class="header" href="#turnmathtoradiansdouble-angle"><code>turn(Math.toRadians(double: angle))</code></a></h4>
<pre><code class="language-java"><span class="boring">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
</span><span class="boring">// This is a simple wait segment that is useful for running actions in between trajectories.
</span><span class="boring">
</span><span class="boring">.waitSeconds(5)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span>// Robot turns counterclockwise by the specified angle
// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
// To turn clockwise, use a negative angle.

.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise to the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// By default, the robot will turn in the shortest direction to the specified heading.
</span><span class="boring">// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
</span><span class="boring">// If it still does not work, you can use the `turn()` method instead.
</span><span class="boring">
</span><span class="boring">.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
</span><span class="boring">.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
</span><span class="boring">// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.
</span><span class="boring">
</span><span class="boring">.setTangent(90) // Sets tangent to 90
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
</span><span class="boring">// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
</span><span class="boring">// This can be fixed by reversing the path using `setReversed(true)`.
</span><span class="boring">
</span><span class="boring">.setReversed(false)  // Unreversed trajectory has hooks on the start and end
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
</span><span class="boring">// This means that:
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">// Is the same as:
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while maintaining its heading.
</span><span class="boring">// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
</span><span class="boring">// So, if you start at a 90 degree angle, it will keep that angle the entire path.
</span><span class="boring">
</span><span class="boring">.strafeTo(new Vector2d(48, -48))
</span><span class="boring">.strafeToConstantHeading(new Vector2d(48, -48))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToX(48)
</span><span class="boring">.lineToXConstantHeading(48)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToY(36)
</span><span class="boring">.lineToYConstantHeading(36)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while keeping the heading constant
</span><span class="boring">// The robot maintains the heading it starts at throughout the trajectory.
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<div class="video-container-2">
    <iframe width="505" height="650"
        src="https://rr-playground-server.brott.dev/ac38839f-39aa-4b0e-ba6c-19f36e3b9bbe.mp4?autoplay=0" title="waitSeconds()" style="border: none;">
    </iframe>
</div>
<style>
.video-container-2 {
    display: flex;
    justify-content: center;
    width: 100%;
    overflow: hidden;
    margin: 0 auto;
    flex-wrap: wrap;
}

@media (max-width: 600px) {
    .video-container-2 {
        width: 328px;
        height: 423px;
    }
    
    .video-container-2 iframe {
        width: 328px;
        height: 423px;
    }
}
</style>
<blockquote>
<p><strong>Why Radians?</strong><br />
You may have noticed that we are turning by \( \frac{\pi}{6} \) degrees instead of degrees.
This is because Road Runner 1.0's units are inches and radians by default. To use degrees, we can convert degrees to radians by using Java's <code>Math.toRadians(degrees)</code></p>
<p>Example:
<code>Math.toRadians(90)</code> converts 90 degrees to radians. 90 degrees is the same as \( \frac{\pi}{2} \) radians.</p>
</blockquote>
<hr />
<h4 id="turntomathtoradiansdouble-heading"><a class="header" href="#turntomathtoradiansdouble-heading"><code>turnTo(Math.toRadians(double: heading))</code></a></h4>
<pre><code class="language-java"><span class="boring">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
</span><span class="boring">// This is a simple wait segment that is useful for running actions in between trajectories.
</span><span class="boring">
</span><span class="boring">.waitSeconds(5)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise by the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
</span><span class="boring">// To turn clockwise, use a negative angle.
</span><span class="boring">
</span><span class="boring">.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
</span><span class="boring">.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span>// Robot turns counterclockwise to the specified angle
// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
// By default, the robot will turn in the shortest direction to the specified heading.
// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
// If it still does not work, you can use the `turn()` method instead.

.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
</span><span class="boring">// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.
</span><span class="boring">
</span><span class="boring">.setTangent(90) // Sets tangent to 90
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
</span><span class="boring">// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
</span><span class="boring">// This can be fixed by reversing the path using `setReversed(true)`.
</span><span class="boring">
</span><span class="boring">.setReversed(false)  // Unreversed trajectory has hooks on the start and end
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
</span><span class="boring">// This means that:
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">// Is the same as:
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while maintaining its heading.
</span><span class="boring">// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
</span><span class="boring">// So, if you start at a 90 degree angle, it will keep that angle the entire path.
</span><span class="boring">
</span><span class="boring">.strafeTo(new Vector2d(48, -48))
</span><span class="boring">.strafeToConstantHeading(new Vector2d(48, -48))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToX(48)
</span><span class="boring">.lineToXConstantHeading(48)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToY(36)
</span><span class="boring">.lineToYConstantHeading(36)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while keeping the heading constant
</span><span class="boring">// The robot maintains the heading it starts at throughout the trajectory.
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<div class = "video-container-3">
    <iframe width="505" height="650"
        src="https://rr-playground-server.brott.dev/7f7f2cc9-155d-483d-a88b-7f2d66741aaa.mp4?autoplay=0" title="waitSeconds()" style="border: none;">
    </iframe>
</div>
<style>
.video-container-3 {
    display: flex;
    justify-content: center;
    width: 100%;
    overflow: hidden;
    margin: 0 auto;
    flex-wrap: wrap;
}

@media (max-width: 600px) {
    .video-container-3 {
        width: 328px;
        height: 423px;
    }
    
    .video-container-3 iframe {
        width: 328px;
        height: 423px;
    }
}
</style>
<hr />
<h4 id="settangentdouble-r"><a class="header" href="#settangentdouble-r"><code>setTangent(double: r)</code></a></h4>
<pre><code class="language-java"><span class="boring">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
</span><span class="boring">// This is a simple wait segment that is useful for running actions in between trajectories.
</span><span class="boring">
</span><span class="boring">.waitSeconds(5)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise by the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
</span><span class="boring">// To turn clockwise, use a negative angle.
</span><span class="boring">
</span><span class="boring">.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
</span><span class="boring">.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise to the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// By default, the robot will turn in the shortest direction to the specified heading.
</span><span class="boring">// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
</span><span class="boring">// If it still does not work, you can use the `turn()` method instead.
</span><span class="boring">
</span><span class="boring">.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
</span><span class="boring">.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span>// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.

.setTangent(90) // Sets tangent to 90
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
</span><span class="boring">// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
</span><span class="boring">// This can be fixed by reversing the path using `setReversed(true)`.
</span><span class="boring">
</span><span class="boring">.setReversed(false)  // Unreversed trajectory has hooks on the start and end
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
</span><span class="boring">// This means that:
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">// Is the same as:
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while maintaining its heading.
</span><span class="boring">// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
</span><span class="boring">// So, if you start at a 90 degree angle, it will keep that angle the entire path.
</span><span class="boring">
</span><span class="boring">.strafeTo(new Vector2d(48, -48))
</span><span class="boring">.strafeToConstantHeading(new Vector2d(48, -48))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToX(48)
</span><span class="boring">.lineToXConstantHeading(48)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToY(36)
</span><span class="boring">.lineToYConstantHeading(36)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while keeping the heading constant
</span><span class="boring">// The robot maintains the heading it starts at throughout the trajectory.
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<hr />
<h4 id="setreversedboolean-reversed"><a class="header" href="#setreversedboolean-reversed"><code>setReversed(boolean: reversed)</code></a></h4>
<pre><code class="language-java"><span class="boring">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
</span><span class="boring">// This is a simple wait segment that is useful for running actions in between trajectories.
</span><span class="boring">
</span><span class="boring">.waitSeconds(5)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise by the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
</span><span class="boring">// To turn clockwise, use a negative angle.
</span><span class="boring">
</span><span class="boring">.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
</span><span class="boring">.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise to the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// By default, the robot will turn in the shortest direction to the specified heading.
</span><span class="boring">// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
</span><span class="boring">// If it still does not work, you can use the `turn()` method instead.
</span><span class="boring">
</span><span class="boring">.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
</span><span class="boring">.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
</span><span class="boring">// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.
</span><span class="boring">
</span><span class="boring">.setTangent(90) // Sets tangent to 90
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span>// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
// This can be fixed by reversing the path using `setReversed(true)`.

.setReversed(false)  // Unreversed trajectory has hooks on the start and end
.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
.setReversed(false)
.splineTo(Vector2d(-48.0, 0.0), Math.PI)
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
</span><span class="boring">// This means that:
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">// Is the same as:
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while maintaining its heading.
</span><span class="boring">// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
</span><span class="boring">// So, if you start at a 90 degree angle, it will keep that angle the entire path.
</span><span class="boring">
</span><span class="boring">.strafeTo(new Vector2d(48, -48))
</span><span class="boring">.strafeToConstantHeading(new Vector2d(48, -48))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToX(48)
</span><span class="boring">.lineToXConstantHeading(48)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToY(36)
</span><span class="boring">.lineToYConstantHeading(36)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while keeping the heading constant
</span><span class="boring">// The robot maintains the heading it starts at throughout the trajectory.
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<div class = "video-container-4">
    <iframe width="505" height="650"
        src="https://rr-playground-server.brott.dev/5e27c06d-330b-42a8-9ce5-d2c5a3cbaf69.mp4" title="waitSeconds()" style="border: none;">
    </iframe>
</div>
<style>
.video-container-4 {
    display: flex;
    justify-content: center;
    width: 100%;
    overflow: hidden;
    margin: 0 auto;
    flex-wrap: wrap;
}

@media (max-width: 600px) {
    .video-container-4 {
        width: 328px;
        height: 423px;
    }
    
    .video-container-4 iframe {
        width: 328px;
        height: 423px;
    }
}
</style>
<pre><code class="language-java"><span class="boring">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
</span><span class="boring">// This is a simple wait segment that is useful for running actions in between trajectories.
</span><span class="boring">
</span><span class="boring">.waitSeconds(5)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise by the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
</span><span class="boring">// To turn clockwise, use a negative angle.
</span><span class="boring">
</span><span class="boring">.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
</span><span class="boring">.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise to the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// By default, the robot will turn in the shortest direction to the specified heading.
</span><span class="boring">// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
</span><span class="boring">// If it still does not work, you can use the `turn()` method instead.
</span><span class="boring">
</span><span class="boring">.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
</span><span class="boring">.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
</span><span class="boring">// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.
</span><span class="boring">
</span><span class="boring">.setTangent(90) // Sets tangent to 90
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
</span><span class="boring">// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
</span><span class="boring">// This can be fixed by reversing the path using `setReversed(true)`.
</span><span class="boring">
</span><span class="boring">.setReversed(false)  // Unreversed trajectory has hooks on the start and end
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span>.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
.setReversed(false)
.splineTo(Vector2d(-48.0, 0.0), Math.PI)
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
</span><span class="boring">// This means that:
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">// Is the same as:
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while maintaining its heading.
</span><span class="boring">// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
</span><span class="boring">// So, if you start at a 90 degree angle, it will keep that angle the entire path.
</span><span class="boring">
</span><span class="boring">.strafeTo(new Vector2d(48, -48))
</span><span class="boring">.strafeToConstantHeading(new Vector2d(48, -48))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToX(48)
</span><span class="boring">.lineToXConstantHeading(48)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToY(36)
</span><span class="boring">.lineToYConstantHeading(36)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while keeping the heading constant
</span><span class="boring">// The robot maintains the heading it starts at throughout the trajectory.
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<div class = "video-container-5">
    <iframe width="505" height="650"
        src="https://rr-playground-server.brott.dev/66e8f52f-8480-4372-bcaa-ee7313a1d637.mp4" title="waitSeconds()" style="border: none;">
    </iframe>
</div>
<style>
.video-container-5 {
    display: flex;
    justify-content: center;
    width: 100%;
    overflow: hidden;
    margin: 0 auto;
    flex-wrap: wrap;
}

@media (max-width: 600px) {
    .video-container-5 {
        width: 328px;
        height: 423px;
    }
    
    .video-container-5 iframe {
        width: 328px;
        height: 423px;
    }
}
</style>
<pre><code class="language-java"><span class="boring">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
</span><span class="boring">// This is a simple wait segment that is useful for running actions in between trajectories.
</span><span class="boring">
</span><span class="boring">.waitSeconds(5)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise by the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
</span><span class="boring">// To turn clockwise, use a negative angle.
</span><span class="boring">
</span><span class="boring">.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
</span><span class="boring">.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise to the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// By default, the robot will turn in the shortest direction to the specified heading.
</span><span class="boring">// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
</span><span class="boring">// If it still does not work, you can use the `turn()` method instead.
</span><span class="boring">
</span><span class="boring">.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
</span><span class="boring">.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
</span><span class="boring">// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.
</span><span class="boring">
</span><span class="boring">.setTangent(90) // Sets tangent to 90
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
</span><span class="boring">// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
</span><span class="boring">// This can be fixed by reversing the path using `setReversed(true)`.
</span><span class="boring">
</span><span class="boring">.setReversed(false)  // Unreversed trajectory has hooks on the start and end
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span>// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
// This means that:
.setReversed(false)
.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
.setReversed(false)
.splineTo(Vector2d(-48.0, 0.0), Math.PI)

// Is the same as:
.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
.splineTo(Vector2d(-48.0, 0.0), Math.PI)
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while maintaining its heading.
</span><span class="boring">// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
</span><span class="boring">// So, if you start at a 90 degree angle, it will keep that angle the entire path.
</span><span class="boring">
</span><span class="boring">.strafeTo(new Vector2d(48, -48))
</span><span class="boring">.strafeToConstantHeading(new Vector2d(48, -48))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToX(48)
</span><span class="boring">.lineToXConstantHeading(48)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToY(36)
</span><span class="boring">.lineToYConstantHeading(36)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while keeping the heading constant
</span><span class="boring">// The robot maintains the heading it starts at throughout the trajectory.
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<hr />
<h4 id="strafetonew-vector2ddouble-x-double-y--strafetoconstantheadingnew-vector2dx-double-y-double"><a class="header" href="#strafetonew-vector2ddouble-x-double-y--strafetoconstantheadingnew-vector2dx-double-y-double"><code>.strafeTo(new Vector2d(double: x, double: y))</code> &amp; <code>.strafeToConstantHeading(new Vector2d(x: double, y: double))</code></a></h4>
<pre><code class="language-java"><span class="boring">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
</span><span class="boring">// This is a simple wait segment that is useful for running actions in between trajectories.
</span><span class="boring">
</span><span class="boring">.waitSeconds(5)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise by the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
</span><span class="boring">// To turn clockwise, use a negative angle.
</span><span class="boring">
</span><span class="boring">.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
</span><span class="boring">.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise to the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// By default, the robot will turn in the shortest direction to the specified heading.
</span><span class="boring">// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
</span><span class="boring">// If it still does not work, you can use the `turn()` method instead.
</span><span class="boring">
</span><span class="boring">.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
</span><span class="boring">.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
</span><span class="boring">// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.
</span><span class="boring">
</span><span class="boring">.setTangent(90) // Sets tangent to 90
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
</span><span class="boring">// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
</span><span class="boring">// This can be fixed by reversing the path using `setReversed(true)`.
</span><span class="boring">
</span><span class="boring">.setReversed(false)  // Unreversed trajectory has hooks on the start and end
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
</span><span class="boring">// This means that:
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">// Is the same as:
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span>// Robot moves to the specified coordinates while maintaining its heading.
// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
// So, if you start at a 90 degree angle, it will keep that angle the entire path.

.strafeTo(new Vector2d(48, -48))
.strafeToConstantHeading(new Vector2d(48, -48))
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToX(48)
</span><span class="boring">.lineToXConstantHeading(48)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToY(36)
</span><span class="boring">.lineToYConstantHeading(36)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while keeping the heading constant
</span><span class="boring">// The robot maintains the heading it starts at throughout the trajectory.
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<div class = "video-container-6">
    <iframe width="505" height="650"
        src="https://rr-playground-server.brott.dev/d06624a8-a8fc-4e0f-8864-8b8768c68f8e.mp4?autoplay=0" title="waitSeconds()" style="border: none;">
    </iframe>
</div>
<style>
.video-container-6 {
    display: flex;
    justify-content: center;
    width: 100%;
    overflow: hidden;
    margin: 0 auto;
    flex-wrap: wrap;
}

@media (max-width: 600px) {
    .video-container-6 {
        width: 328px;
        height: 423px;
    }
    
    .video-container-6 iframe {
        width: 328px;
        height: 423px;
    }
}
</style>
<hr />
<h4 id="strafetolinearheadingnew-vector2dx-y-mathtoradiansheading"><a class="header" href="#strafetolinearheadingnew-vector2dx-y-mathtoradiansheading"><code>.strafeToLinearHeading(new Vector2d(x, y), Math.toRadians(heading))</code></a></h4>
<pre><code class="language-java"><span class="boring">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
</span><span class="boring">// This is a simple wait segment that is useful for running actions in between trajectories.
</span><span class="boring">
</span><span class="boring">.waitSeconds(5)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise by the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
</span><span class="boring">// To turn clockwise, use a negative angle.
</span><span class="boring">
</span><span class="boring">.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
</span><span class="boring">.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise to the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// By default, the robot will turn in the shortest direction to the specified heading.
</span><span class="boring">// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
</span><span class="boring">// If it still does not work, you can use the `turn()` method instead.
</span><span class="boring">
</span><span class="boring">.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
</span><span class="boring">.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
</span><span class="boring">// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.
</span><span class="boring">
</span><span class="boring">.setTangent(90) // Sets tangent to 90
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
</span><span class="boring">// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
</span><span class="boring">// This can be fixed by reversing the path using `setReversed(true)`.
</span><span class="boring">
</span><span class="boring">.setReversed(false)  // Unreversed trajectory has hooks on the start and end
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
</span><span class="boring">// This means that:
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">// Is the same as:
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while maintaining its heading.
</span><span class="boring">// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
</span><span class="boring">// So, if you start at a 90 degree angle, it will keep that angle the entire path.
</span><span class="boring">
</span><span class="boring">.strafeTo(new Vector2d(48, -48))
</span><span class="boring">.strafeToConstantHeading(new Vector2d(48, -48))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span>// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.

.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToX(48)
</span><span class="boring">.lineToXConstantHeading(48)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToY(36)
</span><span class="boring">.lineToYConstantHeading(36)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while keeping the heading constant
</span><span class="boring">// The robot maintains the heading it starts at throughout the trajectory.
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<div class = "video-container-7">
    <iframe width="505" height="650"
        src="https://rr-playground-server.brott.dev/9504527a-6003-46a0-888a-07a4ea487341.mp4?autoplay=0" title="waitSeconds()" style="border: none;">
    </iframe>
</div>
<style>
.video-container-7 {
    display: flex;
    justify-content: center;
    width: 100%;
    overflow: hidden;
    margin: 0 auto;
    flex-wrap: wrap;
}

@media (max-width: 600px) {
    .video-container-7 {
        width: 328px;
        height: 423px;
    }
    
    .video-container-7 iframe {
        width: 328px;
        height: 423px;
    }
}
</style>
<hr />
<h4 id="strafetosplineheadingnew-vector2dx-y-mathtoradiansheading"><a class="header" href="#strafetosplineheadingnew-vector2dx-y-mathtoradiansheading"><code>.strafeToSplineHeading(new Vector2d(x, y), Math.toRadians(heading))</code></a></h4>
<pre><code class="language-java"><span class="boring">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
</span><span class="boring">// This is a simple wait segment that is useful for running actions in between trajectories.
</span><span class="boring">
</span><span class="boring">.waitSeconds(5)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise by the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
</span><span class="boring">// To turn clockwise, use a negative angle.
</span><span class="boring">
</span><span class="boring">.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
</span><span class="boring">.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise to the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// By default, the robot will turn in the shortest direction to the specified heading.
</span><span class="boring">// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
</span><span class="boring">// If it still does not work, you can use the `turn()` method instead.
</span><span class="boring">
</span><span class="boring">.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
</span><span class="boring">.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
</span><span class="boring">// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.
</span><span class="boring">
</span><span class="boring">.setTangent(90) // Sets tangent to 90
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
</span><span class="boring">// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
</span><span class="boring">// This can be fixed by reversing the path using `setReversed(true)`.
</span><span class="boring">
</span><span class="boring">.setReversed(false)  // Unreversed trajectory has hooks on the start and end
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
</span><span class="boring">// This means that:
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">// Is the same as:
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while maintaining its heading.
</span><span class="boring">// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
</span><span class="boring">// So, if you start at a 90 degree angle, it will keep that angle the entire path.
</span><span class="boring">
</span><span class="boring">.strafeTo(new Vector2d(48, -48))
</span><span class="boring">.strafeToConstantHeading(new Vector2d(48, -48))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span>// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.

.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToX(48)
</span><span class="boring">.lineToXConstantHeading(48)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToY(36)
</span><span class="boring">.lineToYConstantHeading(36)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while keeping the heading constant
</span><span class="boring">// The robot maintains the heading it starts at throughout the trajectory.
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<div class = "video-container-8">
    <iframe width="505" height="650"
        src="https://rr-playground-server.brott.dev/6ef27e52-edf0-4501-adeb-8d40b4163bac.mp4?autoplay=0" title="waitSeconds()" style="border: none;">
    </iframe>
</div>
<style>
.video-container-8 {
    display: flex;
    justify-content: center;
    width: 100%;
    overflow: hidden;
    margin: 0 auto;
    flex-wrap: wrap;
}

@media (max-width: 600px) {
    .video-container-8 {
        width: 328px;
        height: 423px;
    }
    
    .video-container-8 iframe {
        width: 328px;
        height: 423px;
    }
}
</style>
<blockquote>
<p><strong>What is the difference between spline interpolation and linear interpolation?</strong></p>
<ul>
<li>Interpolation is a method of finding new data points (angle heading) in between two given data points (initial heading and final heading).</li>
<li>Linear interpolation means that the robot interpolates its heading and turns at a constant, linear rate, from start to the end of the trajectory.</li>
<li>Spline interpolation is the opposite, as the robot turns at a non-linear rate.</li>
</ul>
</blockquote>
<hr />
<h4 id="linetoxx-double--linetoxconstantheadingx-double"><a class="header" href="#linetoxx-double--linetoxconstantheadingx-double"><code>lineToX(x: double)</code> &amp; <code>.lineToXConstantHeading(x: double)</code></a></h4>
<blockquote>
<p>ðŸš¨ <strong>WARNING:</strong> ðŸš¨<br />
It is <strong>HIGHLY RECOMMENDED</strong> to use <a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html"><code>.strafeTo()</code></a> instead of any <code>lineTo()</code>'s! ðŸš¨</p>
</blockquote>
<pre><code class="language-java"><span class="boring">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
</span><span class="boring">// This is a simple wait segment that is useful for running actions in between trajectories.
</span><span class="boring">
</span><span class="boring">.waitSeconds(5)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise by the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
</span><span class="boring">// To turn clockwise, use a negative angle.
</span><span class="boring">
</span><span class="boring">.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
</span><span class="boring">.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise to the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// By default, the robot will turn in the shortest direction to the specified heading.
</span><span class="boring">// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
</span><span class="boring">// If it still does not work, you can use the `turn()` method instead.
</span><span class="boring">
</span><span class="boring">.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
</span><span class="boring">.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
</span><span class="boring">// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.
</span><span class="boring">
</span><span class="boring">.setTangent(90) // Sets tangent to 90
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
</span><span class="boring">// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
</span><span class="boring">// This can be fixed by reversing the path using `setReversed(true)`.
</span><span class="boring">
</span><span class="boring">.setReversed(false)  // Unreversed trajectory has hooks on the start and end
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
</span><span class="boring">// This means that:
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">// Is the same as:
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while maintaining its heading.
</span><span class="boring">// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
</span><span class="boring">// So, if you start at a 90 degree angle, it will keep that angle the entire path.
</span><span class="boring">
</span><span class="boring">.strafeTo(new Vector2d(48, -48))
</span><span class="boring">.strafeToConstantHeading(new Vector2d(48, -48))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span>// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨

.lineToX(48)
.lineToXConstantHeading(48)
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToY(36)
</span><span class="boring">.lineToYConstantHeading(36)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while keeping the heading constant
</span><span class="boring">// The robot maintains the heading it starts at throughout the trajectory.
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<div class = "video-container-9">
    <iframe width="505" height="650"
        src="https://rr-playground-server.brott.dev/658b0f0b-9bce-44c1-af96-6fa34597d1e4.mp4?autoplay=0" title="waitSeconds()" style="border: none;">
    </iframe>
</div>
<style>
.video-container-9 {
    display: flex;
    justify-content: center;
    width: 100%;
    overflow: hidden;
    margin: 0 auto;
    flex-wrap: wrap;
}

@media (max-width: 600px) {
    .video-container-9 {
        width: 328px;
        height: 423px;
    }
    
    .video-container-9 iframe {
        width: 328px;
        height: 423px;
    }
}
</style>
<hr />
<h4 id="linetoyy-double--linetoyconstantheadingy-double"><a class="header" href="#linetoyy-double--linetoyconstantheadingy-double"><code>lineToY(y: double)</code> &amp; <code>.lineToYConstantHeading(y: double)</code></a></h4>
<blockquote>
<p>ðŸš¨ <strong>WARNING:</strong> ðŸš¨<br />
It is <strong>HIGHLY RECOMMENDED</strong> to use <a href="roadrunner_10/../roadrunner_10/complete_trajectorybuilder_reference.html"><code>.strafeTo()</code></a> instead of any <code>lineTo()</code>'s! ðŸš¨</p>
</blockquote>
<pre><code class="language-java"><span class="boring">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
</span><span class="boring">// This is a simple wait segment that is useful for running actions in between trajectories.
</span><span class="boring">
</span><span class="boring">.waitSeconds(5)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise by the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
</span><span class="boring">// To turn clockwise, use a negative angle.
</span><span class="boring">
</span><span class="boring">.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
</span><span class="boring">.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise to the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// By default, the robot will turn in the shortest direction to the specified heading.
</span><span class="boring">// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
</span><span class="boring">// If it still does not work, you can use the `turn()` method instead.
</span><span class="boring">
</span><span class="boring">.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
</span><span class="boring">.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
</span><span class="boring">// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.
</span><span class="boring">
</span><span class="boring">.setTangent(90) // Sets tangent to 90
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
</span><span class="boring">// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
</span><span class="boring">// This can be fixed by reversing the path using `setReversed(true)`.
</span><span class="boring">
</span><span class="boring">.setReversed(false)  // Unreversed trajectory has hooks on the start and end
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
</span><span class="boring">// This means that:
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">// Is the same as:
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while maintaining its heading.
</span><span class="boring">// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
</span><span class="boring">// So, if you start at a 90 degree angle, it will keep that angle the entire path.
</span><span class="boring">
</span><span class="boring">.strafeTo(new Vector2d(48, -48))
</span><span class="boring">.strafeToConstantHeading(new Vector2d(48, -48))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToX(48)
</span><span class="boring">.lineToXConstantHeading(48)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span>// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨

.lineToY(36)
.lineToYConstantHeading(36)
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while keeping the heading constant
</span><span class="boring">// The robot maintains the heading it starts at throughout the trajectory.
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<div class = "video-container-10">
    <iframe width="505" height="650"
        src="https://rr-playground-server.brott.dev/4929bf3f-74f5-45d8-bd1d-244c9ffaaa0d.mp4?autoplay=0" title="waitSeconds()" style="border: none;">
    </iframe>
</div>
<style>
.video-container-10 {
    display: flex;
    justify-content: center;
    width: 100%;
    overflow: hidden;
    margin: 0 auto;
    flex-wrap: wrap;
}

@media (max-width: 600px) {
    .video-container-10 {
        width: 328px;
        height: 423px;
    }
    
    .video-container-10 iframe {
        width: 328px;
        height: 423px;
    }
}
</style>
<hr />
<h4 id="splinetonew-vector2dx-y-tangent--heading-is--fracpi6-"><a class="header" href="#splinetonew-vector2dx-y-tangent--heading-is--fracpi6-"><code>splineTo(new Vector2d(x, y), tangent)</code> | Heading is \( \frac{\pi}{6} \)</a></h4>
<pre><code class="language-java"><span class="boring">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
</span><span class="boring">// This is a simple wait segment that is useful for running actions in between trajectories.
</span><span class="boring">
</span><span class="boring">.waitSeconds(5)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise by the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
</span><span class="boring">// To turn clockwise, use a negative angle.
</span><span class="boring">
</span><span class="boring">.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
</span><span class="boring">.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise to the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// By default, the robot will turn in the shortest direction to the specified heading.
</span><span class="boring">// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
</span><span class="boring">// If it still does not work, you can use the `turn()` method instead.
</span><span class="boring">
</span><span class="boring">.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
</span><span class="boring">.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
</span><span class="boring">// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.
</span><span class="boring">
</span><span class="boring">.setTangent(90) // Sets tangent to 90
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
</span><span class="boring">// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
</span><span class="boring">// This can be fixed by reversing the path using `setReversed(true)`.
</span><span class="boring">
</span><span class="boring">.setReversed(false)  // Unreversed trajectory has hooks on the start and end
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
</span><span class="boring">// This means that:
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">// Is the same as:
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while maintaining its heading.
</span><span class="boring">// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
</span><span class="boring">// So, if you start at a 90 degree angle, it will keep that angle the entire path.
</span><span class="boring">
</span><span class="boring">.strafeTo(new Vector2d(48, -48))
</span><span class="boring">.strafeToConstantHeading(new Vector2d(48, -48))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToX(48)
</span><span class="boring">.lineToXConstantHeading(48)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToY(36)
</span><span class="boring">.lineToYConstantHeading(36)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span>// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator

.splineTo(new Vector2d(48, 48), Math.PI / 2)
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while keeping the heading constant
</span><span class="boring">// The robot maintains the heading it starts at throughout the trajectory.
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<div class = "video-container-11">
    <iframe width="505" height="650"
        src="https://rr-playground-server.brott.dev/6dd76045-92f2-454b-b853-89635c6e9635.mp4?autoplay=0" title="waitSeconds()" style="border: none;">
    </iframe>
</div>
<style>
.video-container-11 {
    display: flex;
    justify-content: center;
    width: 100%;
    overflow: hidden;
    margin: 0 auto;
    flex-wrap: wrap;
}

@media (max-width: 600px) {
    .video-container-11 {
        width: 328px;
        height: 423px;
    }
    
    .video-container-11 iframe {
        width: 328px;
        height: 423px;
    }
}
</style>
<hr />
<h3 id="heading-primitives-1"><a class="header" href="#heading-primitives-1">Heading Primitives</a></h3>
<p>The begin pose is the origin <code>(0,0)</code> with a heading of \( \frac{\pi}{2} \).</p>
<h4 id="tangent-heading-default"><a class="header" href="#tangent-heading-default"><code>Tangent Heading (default)</code></a></h4>
<pre><code class="language-java"><span class="boring">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
</span><span class="boring">// This is a simple wait segment that is useful for running actions in between trajectories.
</span><span class="boring">
</span><span class="boring">.waitSeconds(5)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise by the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
</span><span class="boring">// To turn clockwise, use a negative angle.
</span><span class="boring">
</span><span class="boring">.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
</span><span class="boring">.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise to the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// By default, the robot will turn in the shortest direction to the specified heading.
</span><span class="boring">// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
</span><span class="boring">// If it still does not work, you can use the `turn()` method instead.
</span><span class="boring">
</span><span class="boring">.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
</span><span class="boring">.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
</span><span class="boring">// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.
</span><span class="boring">
</span><span class="boring">.setTangent(90) // Sets tangent to 90
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
</span><span class="boring">// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
</span><span class="boring">// This can be fixed by reversing the path using `setReversed(true)`.
</span><span class="boring">
</span><span class="boring">.setReversed(false)  // Unreversed trajectory has hooks on the start and end
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
</span><span class="boring">// This means that:
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">// Is the same as:
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while maintaining its heading.
</span><span class="boring">// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
</span><span class="boring">// So, if you start at a 90 degree angle, it will keep that angle the entire path.
</span><span class="boring">
</span><span class="boring">.strafeTo(new Vector2d(48, -48))
</span><span class="boring">.strafeToConstantHeading(new Vector2d(48, -48))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToX(48)
</span><span class="boring">.lineToXConstantHeading(48)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToY(36)
</span><span class="boring">.lineToYConstantHeading(36)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span>// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator

.setTangent(0)
.splineTo(new Vector2d(48, 48), Math.PI / 2)
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while keeping the heading constant
</span><span class="boring">// The robot maintains the heading it starts at throughout the trajectory.
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<div class = "video-container-12">
    <iframe width="505" height="650"
        src="https://rr-playground-server.brott.dev/22fefc44-44cb-42dd-bac5-1384cfa2d35d.mp4?autoplay=0" title="waitSeconds()" style="border: none;">
    </iframe>
</div>
<style>
.video-container-12 {
    display: flex;
    justify-content: center;
    width: 100%;
    overflow: hidden;
    margin: 0 auto;
    flex-wrap: wrap;
}

@media (max-width: 600px) {
    .video-container-12 {
        width: 328px;
        height: 423px;
    }
    
    .video-container-12 iframe {
        width: 328px;
        height: 423px;
    }
}
</style>
<hr />
<h4 id="constant-heading"><a class="header" href="#constant-heading"><code>Constant Heading</code></a></h4>
<pre><code class="language-java"><span class="boring">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
</span><span class="boring">// This is a simple wait segment that is useful for running actions in between trajectories.
</span><span class="boring">
</span><span class="boring">.waitSeconds(5)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise by the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
</span><span class="boring">// To turn clockwise, use a negative angle.
</span><span class="boring">
</span><span class="boring">.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
</span><span class="boring">.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise to the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// By default, the robot will turn in the shortest direction to the specified heading.
</span><span class="boring">// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
</span><span class="boring">// If it still does not work, you can use the `turn()` method instead.
</span><span class="boring">
</span><span class="boring">.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
</span><span class="boring">.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
</span><span class="boring">// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.
</span><span class="boring">
</span><span class="boring">.setTangent(90) // Sets tangent to 90
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
</span><span class="boring">// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
</span><span class="boring">// This can be fixed by reversing the path using `setReversed(true)`.
</span><span class="boring">
</span><span class="boring">.setReversed(false)  // Unreversed trajectory has hooks on the start and end
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
</span><span class="boring">// This means that:
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">// Is the same as:
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while maintaining its heading.
</span><span class="boring">// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
</span><span class="boring">// So, if you start at a 90 degree angle, it will keep that angle the entire path.
</span><span class="boring">
</span><span class="boring">.strafeTo(new Vector2d(48, -48))
</span><span class="boring">.strafeToConstantHeading(new Vector2d(48, -48))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToX(48)
</span><span class="boring">.lineToXConstantHeading(48)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToY(36)
</span><span class="boring">.lineToYConstantHeading(36)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span>// Robot moves to the specified coordinates in a spline path while keeping the heading constant
// The robot maintains the heading it starts at throughout the trajectory.
// To change the shape of the spline, change `endTangent`.

.setTangent(0)
.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<div class = "video-container-13">
    <iframe width="505" height="650"
        src="https://rr-playground-server.brott.dev/05d9298e-6737-4a08-9374-dd09725d1a2d.mp4?autoplay=0" title="waitSeconds()" style="border: none;">
    </iframe>
</div>
<style>
.video-container-13 {
    display: flex;
    justify-content: center;
    width: 100%;
    overflow: hidden;
    margin: 0 auto;
    flex-wrap: wrap;
}

@media (max-width: 600px) {
    .video-container-13 {
        width: 328px;
        height: 423px;
    }
    
    .video-container-13 iframe {
        width: 328px;
        height: 423px;
    }
}
</style>
<hr />
<h4 id="linear-heading"><a class="header" href="#linear-heading"><code>Linear Heading</code></a></h4>
<pre><code class="language-java"><span class="boring">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
</span><span class="boring">// This is a simple wait segment that is useful for running actions in between trajectories.
</span><span class="boring">
</span><span class="boring">.waitSeconds(5)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise by the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
</span><span class="boring">// To turn clockwise, use a negative angle.
</span><span class="boring">
</span><span class="boring">.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
</span><span class="boring">.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise to the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// By default, the robot will turn in the shortest direction to the specified heading.
</span><span class="boring">// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
</span><span class="boring">// If it still does not work, you can use the `turn()` method instead.
</span><span class="boring">
</span><span class="boring">.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
</span><span class="boring">.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
</span><span class="boring">// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.
</span><span class="boring">
</span><span class="boring">.setTangent(90) // Sets tangent to 90
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
</span><span class="boring">// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
</span><span class="boring">// This can be fixed by reversing the path using `setReversed(true)`.
</span><span class="boring">
</span><span class="boring">.setReversed(false)  // Unreversed trajectory has hooks on the start and end
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
</span><span class="boring">// This means that:
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">// Is the same as:
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while maintaining its heading.
</span><span class="boring">// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
</span><span class="boring">// So, if you start at a 90 degree angle, it will keep that angle the entire path.
</span><span class="boring">
</span><span class="boring">.strafeTo(new Vector2d(48, -48))
</span><span class="boring">.strafeToConstantHeading(new Vector2d(48, -48))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToX(48)
</span><span class="boring">.lineToXConstantHeading(48)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToY(36)
</span><span class="boring">.lineToYConstantHeading(36)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while keeping the heading constant
</span><span class="boring">// The robot maintains the heading it starts at throughout the trajectory.
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span>// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
// To change the shape of the spline, change `endTangent`.

.setTangent(0)
.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
<span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span></code></pre>
<div class = "video-container-14">
    <iframe width="505" height="650"
        src="https://rr-playground-server.brott.dev/d8b9fdef-59c9-415b-86fb-a68616f34bb0.mp4?autoplay=0" title="waitSeconds()" style="border: none;">
    </iframe>
</div>
<style>
.video-container-14 {
    display: flex;
    justify-content: center;
    width: 100%;
    overflow: hidden;
    margin: 0 auto;
    flex-wrap: wrap;
}

@media (max-width: 600px) {
    .video-container-14 {
        width: 328px;
        height: 423px;
    }
    
    .video-container-14 iframe {
        width: 328px;
        height: 423px;
    }
}
</style>
<hr />
<h4 id="spline-heading"><a class="header" href="#spline-heading"><code>Spline Heading</code></a></h4>
<pre><code class="language-java"><span class="boring">// Robot waits for the specified time in seconds (NOT MILLISECONDS!)
</span><span class="boring">// This is a simple wait segment that is useful for running actions in between trajectories.
</span><span class="boring">
</span><span class="boring">.waitSeconds(5)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise by the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// If you see `Math.PI`, it is already in radians, and does not need `Math.toRadians()`. Degrees from 0 to 360 need to be converted to radians.
</span><span class="boring">// To turn clockwise, use a negative angle.
</span><span class="boring">
</span><span class="boring">.turn(-Math.PI / 6) // Turns clockwise by `Math.PI / 6` degrees, ending at a heading of 0 degrees
</span><span class="boring">.turn(Math.PI / 6) // Turns counterclockwise by `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot turns counterclockwise to the specified angle
</span><span class="boring">// This turn is in radians, so you must convert your degrees to radians using `Math.toRadians()`.
</span><span class="boring">// By default, the robot will turn in the shortest direction to the specified heading.
</span><span class="boring">// To turn in the opposite direction, you can add or subtract a very small number (1e-6) to the heading you want to turn to.
</span><span class="boring">// If it still does not work, you can use the `turn()` method instead.
</span><span class="boring">
</span><span class="boring">.turnTo(Math.toRadians(90)) // Turns to a heading of 90 degrees
</span><span class="boring">.turnTo(Math.PI / 6) // Turns to a heading of `Math.PI / 6` degrees, ending at the original heading
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// `setTangent()` allows you to set a heading tangent on a trajectory, allowing you to follow a trajectory at arbitrary heading tangents
</span><span class="boring">// This is equivalent to specifying a custom tangent in the `TrajectoryBuilder()` constructor.
</span><span class="boring">
</span><span class="boring">.setTangent(90) // Sets tangent to 90
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// If you see these hooks on the start and/or end of spline trajectories, you can use `setReversed()` to fix them
</span><span class="boring">// These hooks make your robot move backwards instead of forward or vice versa in splines, creating suboptimal paths.
</span><span class="boring">// This can be fixed by reversing the path using `setReversed(true)`.
</span><span class="boring">
</span><span class="boring">.setReversed(false)  // Unreversed trajectory has hooks on the start and end
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">.setReversed(true)  // Reversed trajectory has no hooks on the start and end, and is smooth
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// By default, each trajectory is set to `setReversed(false)`, which does not reverse the paths.
</span><span class="boring">// This means that:
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.setReversed(false)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">// Is the same as:
</span><span class="boring">.splineTo(Vector2d(-48.0, -24.0), -Math.PI / 2)
</span><span class="boring">.splineTo(Vector2d(-48.0, 0.0), Math.PI)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while maintaining its heading.
</span><span class="boring">// Both `strafeTo()` and `strafeToConstantHeading()` are equivalent.
</span><span class="boring">// So, if you start at a 90 degree angle, it will keep that angle the entire path.
</span><span class="boring">
</span><span class="boring">.strafeTo(new Vector2d(48, -48))
</span><span class="boring">.strafeToConstantHeading(new Vector2d(48, -48))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while linearly interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToLinearHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates while splinely interpolating between the start heading and a specified end heading
</span><span class="boring">// In other words, it constantly turns to a certain heading (once more, in radians) while moving to the specified coordinates.
</span><span class="boring">
</span><span class="boring">.strafeToSplineHeading(new Vector2d(36, 36), Math.toRadians(90))
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified x coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToX()` and `lineToXConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToX(48)
</span><span class="boring">.lineToXConstantHeading(48)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified y coordinate in the direction of the robot heading (straight line).
</span><span class="boring">// Both `lineToY()` and `lineToYConstantHeading()` are equivalent.
</span><span class="boring">// ðŸš¨ Will cause an error if your heading is perpendicular to direction your robot is traveling! ðŸš¨
</span><span class="boring">
</span><span class="boring">.lineToY(36)
</span><span class="boring">.lineToYConstantHeading(36)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while following a tangent heading interpolator
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineTo(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while keeping the heading constant
</span><span class="boring">// The robot maintains the heading it starts at throughout the trajectory.
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToConstantHeading(new Vector2d(48, 48), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">// Robot moves to the specified coordinates in a spline path while separately linearly interpolating the heading
</span><span class="boring">// To change the shape of the spline, change `endTangent`.
</span><span class="boring">
</span><span class="boring">.setTangent(0)
</span><span class="boring">.splineToLinearHeading(new Pose2d(48, 48, 0), Math.PI / 2)
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">
</span>// Robot moves to the specified coordinates in a spline path while separately spline interpolating the heading
// To change the shape of the spline, change `endTangent`.

.setTangent(0)
.splineToSplineHeading(new Pose2d(48, 48, 0), Math.PI / 2)
<span class="boring">
</span><span class="boring">
</span></code></pre>
<div class = "video-container-15">
    <iframe width="505" height="650"
        src="https://rr-playground-server.brott.dev/05d9298e-6737-4a08-9374-dd09725d1a2d.mp4?autoplay=0" title="waitSeconds()" style="border: none;">
    </iframe>
</div>
<style>
.video-container-15 {
    display: flex;
    justify-content: center;
    width: 100%;
    overflow: hidden;
    margin: 0 auto;
    flex-wrap: wrap;
}

@media (max-width: 600px) {
    .video-container-15 {
        width: 328px;
        height: 423px;
    }
    
    .video-container-15 iframe {
        width: 328px;
        height: 423px;
    }
}
</style>
<hr />
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><a href="https://rr.brott.dev/docs/v1-0/builder-ref/">Official Road Runner 1.0 Builder Reference</a></li>
<li><a href="https://rr.brott.dev/playground/">Official Road Runner 1.0 Builder Playground</a></li>
<li><a href="https://rr.brott.dev/playground/?367582b88299b654"><code>waitSeconds()</code> Video Playground</a></li>
<li><a href="https://rr.brott.dev/playground/?5a434271b239e5bc"><code>turn()</code> Video Playground</a></li>
<li><a href="https://rr.brott.dev/playground/?ad40438ae13740f7"><code>turnTo()</code> Video Playground</a></li>
<li><a href="https://rr.brott.dev/playground/?78c18fcfaa629ea1"><code>.setReversed(false)</code> Video Playground</a></li>
<li><a href="https://rr.brott.dev/playground/?f13b09a93d37031c"><code>.setReversed(true)</code> Video Playground</a></li>
<li><a href="https://rr.brott.dev/playground/?f49042fdf5ea3ab0"><code>strafeTo()</code> / <code>strafeToConstantHeading()</code> Video Playground</a></li>
<li><a href="https://rr.brott.dev/playground/?ed5d41566d46b59f"><code>.strafeToLinearHeading()</code> Video Playground</a></li>
<li><a href="https://rr.brott.dev/playground/?2df122402fceaecc"><code>.strafeToSplineHeading()</code> Video Playground</a></li>
<li><a href="https://rr.brott.dev/playground/?24fae2ad24c95f39"><code>.lineToX()</code> Video Playground</a></li>
<li><a href="https://rr.brott.dev/playground/?539e8ead2f501b29"><code>.lineToY()</code> Video Playground</a></li>
<li><a href="https://rr.brott.dev/playground/?0a660e7b5fae2b70d"><code>.splineTo()</code> Video Playground</a></li>
<li><a href="https://rr.brott.dev/playground/?728d3c0e2e969023"><code>.splineTo() (default)</code> Video Playground</a></li>
<li><a href="https://rr.brott.dev/playground/?31ac47a09d8222c7"><code>.splineToConstantHeading()</code> Video Playground</a></li>
<li><a href="https://rr.brott.dev/playground/?b152980ce38bbdaa"><code>.splineToLinearHeading()</code> Video Playground</a></li>
<li><a href="https://rr.brott.dev/playground/?9c422405d44fed70"><code>.splineToSplineHeading()</code> Video Playground</a></li>
</ul>
<hr />
<p><em>Last Updated: 2024-07-29</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="is-the-bump-on-manual-feedforward-tuner-normal"><a class="header" href="#is-the-bump-on-manual-feedforward-tuner-normal">Is the Bump On Manual Feedforward Tuner Normal?</a></h1>
<p><img src="roadrunner_056/../static/is_the_bump_on_manual_feedforward_tuner_normal/deceleration_bump.png" alt="image of deceleration bump" /></p>
<p>Yes!
The bump when accelerating and decelerating is normal.
It is caused by a fundamental hardware issue with the Control and Expansion Hubs that makes deceleration weird.
There's nothing you can do about it; just try to get the plates and slopes to match up as closely as possible.</p>
<p><em>Last Updated: 2024-05-29</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-feedforward-tuner-overshoots"><a class="header" href="#manual-feedforward-tuner-overshoots">Manual Feedforward Tuner Overshoots</a></h1>
<p>This is normal!
The REV hub motor controllers are not great at decelerating, so this typically causes about a 10% overshoot on manual feedforward tuner.
It is okay to move on to the next tuning steps.</p>
<p>However, when you get to the feedback tuning, whether it's "Back and Forth" or "FollowerPIDTuner," you will want to add a non-zero kD term.
This will help the robot not overshoot.</p>
<p><em>Last Updated: 2024-05-30</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="target-velocity-is-positive-when-measured-velocity-is-negative-when-tuning-manual-feedforward"><a class="header" href="#target-velocity-is-positive-when-measured-velocity-is-negative-when-tuning-manual-feedforward">Target Velocity is Positive When Measured Velocity is Negative When Tuning Manual Feedforward</a></h1>
<p>If MotorDirectionDebugger works perfectly, this means that either your right side encoders are plugged in to the wrong ports (so swap <code>frontRight</code> and <code>backRight</code> encoder cables) or your left side encoders are plugged in to the wrong ports (so swap <code>frontLeft</code> and <code>backLeft</code> encoder cables).
An easy way to debug this is to add a <code>printEncoderValues</code> telemetry method in <code>SampleMecanumDrive</code>.</p>
<pre><code class="language-java">public void printEncoderValues(Telemetry telemetry) {
        telemetry.addData("LeftFrontPos: ", leftFront.getCurrentPosition());
        telemetry.addData("RightFrontPos: ", rightFront.getCurrentPosition());
        telemetry.addData("LeftRearPos: ", leftRear.getCurrentPosition());
        telemetry.addData("RightBackPos: ", rightRear.getCurrentPosition());
} 
</code></pre>
<p>Then at the end of every loop in MotorDirectionDebugger, call</p>
<pre><code class="language-java">drive.printEncoderValues(telemetry);
</code></pre>
<p><em>Last updated: 2024-05-30</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="robot-localization-makes-circle-when-spinning-in-place"><a class="header" href="#robot-localization-makes-circle-when-spinning-in-place">Robot Localization Makes Circle When Spinning In Place</a></h1>
<p>So when you spin the robot in place, the drawing on FTC Dashboard is making a circle.
This is normal and can be fixed.</p>
<h3 id="what-causes-it"><a class="header" href="#what-causes-it">What causes it?</a></h3>
<p>When the robot is spun, the strafing odometry wheel moves which makes the localization think the robot moved in a circle.
This can be counteracted using the forward distance from the strafing tracking wheel to the center of rotation.</p>
<h3 id="three-wheel-solution"><a class="header" href="#three-wheel-solution">Three Wheel Solution</a></h3>
<p>For three wheel odometry, this means your forward offset isn't tuned correctly.
Run the tuner and replace the value.
If that doesn't work, check whether the strafing pod is closer to the front or the back of the robot.
If it's closer to the back, the offset should be negative.</p>
<h3 id="two-wheel-solution"><a class="header" href="#two-wheel-solution">Two Wheel Solution</a></h3>
<p>The solution for two wheel odometry is largely the same.
Instead of the forward offset, you must tune the x and y position of the strafing pod.
The same advice about positive and negative offset still applies.</p>
<p><em>Last Updated: 2024-05-30</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="robot-velocity-plateaus-below-target-velocity-plateaus"><a class="header" href="#robot-velocity-plateaus-below-target-velocity-plateaus">Robot Velocity Plateaus Below Target Velocity Plateaus</a></h1>
<p><img src="roadrunner_056/../static/robot_velocity_plateaus_below_target_velocity_plateau/lowPlateau.png" alt="image of robot velocity not reaching max target velocity" /></p>
<p>This means you've reached your robot's actual max velocity.
You should lower the max velocity specified in DriveConstants.
Run the MaxVelocityTuner to find the recommended max velocity to use.</p>
<p><em>Last Updated: 2024-02-08</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="robot-drifts-to-one-side-during-manual-feedforward-tuning"><a class="header" href="#robot-drifts-to-one-side-during-manual-feedforward-tuning">Robot Drifts to One Side During Manual Feedforward Tuning</a></h1>
<p>If this happens, you shouldn't worry.
This can be caused by many reasons, such as an unbalanced robot or one wheel having slightly more friction than the others.</p>
<p>Whatever the reason, this will be corrected for in the later tuning steps.
It can safely be ignored.</p>
<p><em>Last Updated: 2024-05-30</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="robot-drifts-while-tuning-follower-pid"><a class="header" href="#robot-drifts-while-tuning-follower-pid">Robot Drifts While Tuning Follower PID</a></h1>
<h3 id="check-localization"><a class="header" href="#check-localization">Check Localization</a></h3>
<p>Run <code>LocalizationTest</code> and drive the robot back and forth a few times.
You want to ensure that the behavior shown on the dashboard mirrors that of what you can see.
If the robot was veering in <code>BackAndForth</code>, see if the dashboard bot is veering the same.
If you notice the same discrepancy while running <code>LocalizationTest</code>, it means the problem is in your localization.</p>
<h3 id="tuning-pid"><a class="header" href="#tuning-pid">Tuning PID</a></h3>
<p>If you're certain that localization works fine and the robot "knows" that it's wrong, but isn't correcting, then you need to tune your PID values more.
You can tune your controller through the steps on <a href="https://gm0.org/en/latest/docs/software/concepts/control-loops.html#tuning-a-pid-loop">this page of Game Manual 0</a>.</p>
<p><em>Last Updated: 2024-01-21</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="robot-drive-full-speed-on-start-when-following-trajectory"><a class="header" href="#robot-drive-full-speed-on-start-when-following-trajectory">Robot Drive Full Speed on Start When Following Trajectory</a></h1>
<p>If you are running an OpMode that has Roadrunner trajectories in it, and when you start moving it goes at full speed right away, this almost always means you forgot to set a pose estimate.
In <code>init()</code>, before you run any trajectories, make sure you have <code>drive.setPoseEstimate(startingPose)</code>, whatever your starting pose may be.
Make sure that the trajectory starting pose matches this:</p>
<pre><code class="language-java">Trajectory traj = drive.trajectoryBuilder(startingPose)
    ...
    .build();
</code></pre>
<p><em>Last Updated: 2024-01-20</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-integrate-a-pidf-controller-with-roadrunner"><a class="header" href="#how-to-integrate-a-pidf-controller-with-roadrunner">How to Integrate a PIDF Controller With Roadrunner</a></h1>
<p><em>This recipe will assume you have a functioning PIDF controller that has already been tuned. If you do not, refer to <a href="roadrunner_056/how_to_integrate_a_PIDF_controller_with_roadrunner/./how_to_integrate_a_PIDF_controller_with_roadrunner.html">integrating a custom PIDF controller</a>.</em></p>
<h2 id="ingredients-4"><a class="header" href="#ingredients-4">Ingredients</a></h2>
<ol>
<li>A PID or PIDF controller class</li>
<li>Tuned PID(F) gains</li>
<li>An OpMode or LinearOpMode</li>
<li>A Finite State Machine</li>
</ol>
<h2 id="the-recipe-1"><a class="header" href="#the-recipe-1">The Recipe</a></h2>
<h3 id="pidf-controller-and-gains"><a class="header" href="#pidf-controller-and-gains">PID(F) Controller and gains</a></h3>
<p>This recipe assumes you have 1) a PID(F) class that works and 2) tuned PID(F) gains.
This recipe will not go over how to implement these; you should reference <a href="roadrunner_056/how_to_integrate_a_PIDF_controller_with_roadrunner/./how_to_integrate_a_PIDF_controller_with_roadrunner.html">integrating a custom PIDF controller</a>.</p>
<h3 id="finite-state-machines"><a class="header" href="#finite-state-machines">Finite State Machines</a></h3>
<p>In short, a finite state machine is a code structure which allows code to run linearly while also having quasi-parallel actions running.
The example we will be working with today is driving with Roadrunner while controlling linear slides.
For a more indepth understanding of what finite state machines are, visit <a href="https://gm0.org/en/latest/docs/software/concepts/finite-state-machines.html?highlight=finite">gm0</a>.</p>
<p>You can work with Finite State Machines in either a LinearOpMode or an OpMode, either work.
For this recipe, we will be using a LinearOpMode.
To use an OpMode, move everything before the while loop into the <code>init()</code> function and everything in the while loop into the <code>loop()</code> function.</p>
<p>We will first have a full example and then break it down piece by piece.</p>
<p><em>This example is more like pseudocode than real code and is meant to demonstrate a methodology.</em></p>
<pre><code class="language-java">public class RoadRunnerPIDF extends LinearOpMode {
    // the capitalization and snake_case is just convention because the values of an enum are constants
    public enum STATES {
        INIT,
        DRIVE_FORWARD,
        STRAFE_LEFT_AND_LIFT_SLIDES,
        DRIVE_BACKWARD,
        STOP;
    }

    private STATES previousState = STATES.INIT;
    private STATES currentState = STATES.INIT;
    private int targetPosition = 0;

    private TrajectorySequence forward;
    private TrajectorySequence strafeLeft;
    private TrajectorySequence backward;

    private SampleMecanumDrive drive;
    private DcMotorEx linearSlides;
    private PIDFController PIDF;

    public void runOpMode() {
        /* for the purpose of this recipe, I will be using linear slides with PIDF control to demonstrate.
        The linear slides will simply be called linearSlides.
        */

        // linear slide initialization code
        // pidf initialization code

        drive = new SampleMecanumDrive(hardwareMap);
        drive.setPoseEstimate(new Pose2d());

        forward = drive.TrajectorySequenceBuilder(new Pose2d())
            .forward(10)
            .build();

        strafeLeft = drive.TrajectorySequenceBuilder(forward.end())
            .addDisplacementMarker(() -&gt; {
                targetPosition = 800;
            })
            .strafeLeft(10)
            .build();

        backward = drive.TrajectorySequenceBuilder(strafeLeft.end())
            .back(10)
            .build();

        waitForStart();

        currentState = STATES.DRIVE_FORWARD;

        while(opModeIsActive) {
            switch (currentState) {
                case (INIT):
                    break;
                case (DRIVE_FORWARD):
                    if (previousState != currentState) {
                        // everything in here will run once when the state switches

                        drive.followTrajectoryAsync(forward)
                        previousState = STATES.DRIVE_FORWARD;
                    } else if (!drive.isBusy()) {
                        currentState = STATES.STRAFE_LEFT_AND_LIFT_SLIDES;
                    }
                    break;
                case (STRAFE_LEFT_AND_LIFT_SLIDES):
                    if (previousState != currentState) {
                        // inside this trajectory sequence the targetPosition is set and the slides will start updating
                        drive.followTrajectorySequenceAsync(strafeLeft);
                    } else if (!drive.isBusy() &amp;&amp; linearSlides.atTarget()) {
                        currentState = STATES.DRIVE_BACKWARD;
                    }
                    break;
                case (DRIVE_BACKWARD):
                    if (previousState != currentState) {
                        drive.followTrajectorySequenceAsync(backward);
                        previousState = STATES.DRIVE_BACKWARD;
                    } else if (!drive.isBusy()) {
                        currentState = STATES.STOP;
                    }
                    break;
                case (STOP):
                    break;
            }

            // outside of the switch we update our slides, that way they are always receiving new information
            drive.update();
            double power = PIDF.calculate(linearSlides.getCurrentPosition(), targetPosition)
            linearSlides.setPower(power);
        }
    }
}
</code></pre>
<p>Okay, let's break this down piece by piece.
First, what is an "enum" and why do we use them?
Enums are a way to define a set of named constant values.
They provide a convenient and readable way to work with predefined, named values in your code.
Here, we used an enum to describe the various states the robot could be in.</p>
<pre><code class="language-java"><span class="boring">public class RoadRunnerPIDF extends LinearOpMode {
</span><span class="boring">    // the capitalization and snake_case is just convention because the values of an enum are constants
</span>    public enum STATES {
        INIT,
        DRIVE_FORWARD,
        STRAFE_LEFT_AND_LIFT_SLIDES,
        DRIVE_BACKWARD,
        STOP;
    }
<span class="boring">
</span><span class="boring">    private STATES previousState = STATES.INIT;
</span><span class="boring">    private STATES currentState = STATES.INIT;
</span><span class="boring">    private int targetPosition = 0;
</span><span class="boring">
</span><span class="boring">    private TrajectorySequence forward;
</span><span class="boring">    private TrajectorySequence strafeLeft;
</span><span class="boring">    private TrajectorySequence backward;
</span><span class="boring">
</span><span class="boring">    private SampleMecanumDrive drive;
</span><span class="boring">    private DcMotorEx linearSlides;
</span><span class="boring">    private PIDFController PIDF;
</span><span class="boring">
</span><span class="boring">    public void runOpMode() {
</span><span class="boring">        /* for the purpose of this recipe, I will be using linear slides with PIDF control to demonstrate.
</span><span class="boring">        The linear slides will simply be called linearSlides.
</span><span class="boring">        */
</span><span class="boring">
</span><span class="boring">        // linear slide initialization code
</span><span class="boring">        // pidf initialization code
</span><span class="boring">
</span><span class="boring">        drive = new SampleMecanumDrive(hardwareMap);
</span><span class="boring">        drive.setPoseEstimate(new Pose2d());
</span><span class="boring">
</span><span class="boring">        forward = drive.TrajectorySequenceBuilder(new Pose2d())
</span><span class="boring">            .forward(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        strafeLeft = drive.TrajectorySequenceBuilder(forward.end())
</span><span class="boring">            .addDisplacementMarker(() -&gt; {
</span><span class="boring">                targetPosition = 800;
</span><span class="boring">            })
</span><span class="boring">            .strafeLeft(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        backward = drive.TrajectorySequenceBuilder(strafeLeft.end())
</span><span class="boring">            .back(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        waitForStart();
</span><span class="boring">
</span><span class="boring">        currentState = STATES.DRIVE_FORWARD;
</span><span class="boring">
</span><span class="boring">        while(opModeIsActive) {
</span><span class="boring">            switch (currentState) {
</span><span class="boring">                case (INIT):
</span><span class="boring">                    break;
</span><span class="boring">                case (DRIVE_FORWARD):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        // everything in here will run once when the state switches
</span><span class="boring">
</span><span class="boring">                        drive.followTrajectoryAsync(forward)
</span><span class="boring">                        previousState = STATES.DRIVE_FORWARD;
</span><span class="boring">                    } else if (!drive.isBusy()) {
</span><span class="boring">                        currentState = STATES.STRAFE_LEFT_AND_LIFT_SLIDES;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (STRAFE_LEFT_AND_LIFT_SLIDES):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        // inside this trajectory sequence the targetPosition is set and the slides will start updating
</span><span class="boring">                        drive.followTrajectorySequenceAsync(strafeLeft);
</span><span class="boring">                    } else if (!drive.isBusy() &amp;&amp; linearSlides.atTarget()) {
</span><span class="boring">                        currentState = STATES.DRIVE_BACKWARD;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (DRIVE_BACKWARD):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        drive.followTrajectorySequenceAsync(backward);
</span><span class="boring">                        previousState = STATES.DRIVE_BACKWARD;
</span><span class="boring">                    } else if (!drive.isBusy()) {
</span><span class="boring">                        currentState = STATES.STOP;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (STOP):
</span><span class="boring">                    break;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            // outside of the switch we update our slides, that way they are always receiving new information
</span><span class="boring">            drive.update();
</span><span class="boring">            double power = PIDF.calculate(linearSlides.getCurrentPosition(), targetPosition)
</span><span class="boring">            linearSlides.setPower(power);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>By using names with meaning like these, it is much clearer when writing and reading the code what each block does.
It also means we don't have to remember that state 0 means START and state 1 means DRIVE_FORWARD, etc.</p>
<p>Next, we initialize everything and build our trajectories.
The important one to note is creating <code>strafeLeft</code>, which includes slide movement.</p>
<pre><code class="language-java"><span class="boring">public class RoadRunnerPIDF extends LinearOpMode {
</span><span class="boring">    // the capitalization and snake_case is just convention because the values of an enum are constants
</span><span class="boring">    public enum STATES {
</span><span class="boring">        INIT,
</span><span class="boring">        DRIVE_FORWARD,
</span><span class="boring">        STRAFE_LEFT_AND_LIFT_SLIDES,
</span><span class="boring">        DRIVE_BACKWARD,
</span><span class="boring">        STOP;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    private STATES previousState = STATES.INIT;
</span><span class="boring">    private STATES currentState = STATES.INIT;
</span><span class="boring">    private int targetPosition = 0;
</span><span class="boring">
</span><span class="boring">    private TrajectorySequence forward;
</span><span class="boring">    private TrajectorySequence strafeLeft;
</span><span class="boring">    private TrajectorySequence backward;
</span><span class="boring">
</span><span class="boring">    private SampleMecanumDrive drive;
</span><span class="boring">    private DcMotorEx linearSlides;
</span><span class="boring">    private PIDFController PIDF;
</span><span class="boring">
</span><span class="boring">    public void runOpMode() {
</span><span class="boring">        /* for the purpose of this recipe, I will be using linear slides with PIDF control to demonstrate.
</span><span class="boring">        The linear slides will simply be called linearSlides.
</span><span class="boring">        */
</span><span class="boring">
</span><span class="boring">        // linear slide initialization code
</span><span class="boring">        // pidf initialization code
</span><span class="boring">
</span><span class="boring">        drive = new SampleMecanumDrive(hardwareMap);
</span><span class="boring">        drive.setPoseEstimate(new Pose2d());
</span><span class="boring">
</span><span class="boring">        forward = drive.TrajectorySequenceBuilder(new Pose2d())
</span><span class="boring">            .forward(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span>        strafeLeft = drive.TrajectorySequenceBuilder(forward.end())
            .addDisplacementMarker(() -&gt; {
                targetPosition = 800;
            })
            .strafeLeft(10)
            .build();
<span class="boring">
</span><span class="boring">        backward = drive.TrajectorySequenceBuilder(strafeLeft.end())
</span><span class="boring">            .back(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        waitForStart();
</span><span class="boring">
</span><span class="boring">        currentState = STATES.DRIVE_FORWARD;
</span><span class="boring">
</span><span class="boring">        while(opModeIsActive) {
</span><span class="boring">            switch (currentState) {
</span><span class="boring">                case (INIT):
</span><span class="boring">                    break;
</span><span class="boring">                case (DRIVE_FORWARD):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        // everything in here will run once when the state switches
</span><span class="boring">
</span><span class="boring">                        drive.followTrajectoryAsync(forward)
</span><span class="boring">                        previousState = STATES.DRIVE_FORWARD;
</span><span class="boring">                    } else if (!drive.isBusy()) {
</span><span class="boring">                        currentState = STATES.STRAFE_LEFT_AND_LIFT_SLIDES;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (STRAFE_LEFT_AND_LIFT_SLIDES):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        // inside this trajectory sequence the targetPosition is set and the slides will start updating
</span><span class="boring">                        drive.followTrajectorySequenceAsync(strafeLeft);
</span><span class="boring">                    } else if (!drive.isBusy() &amp;&amp; linearSlides.atTarget()) {
</span><span class="boring">                        currentState = STATES.DRIVE_BACKWARD;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (DRIVE_BACKWARD):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        drive.followTrajectorySequenceAsync(backward);
</span><span class="boring">                        previousState = STATES.DRIVE_BACKWARD;
</span><span class="boring">                    } else if (!drive.isBusy()) {
</span><span class="boring">                        currentState = STATES.STOP;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (STOP):
</span><span class="boring">                    break;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            // outside of the switch we update our slides, that way they are always receiving new information
</span><span class="boring">            drive.update();
</span><span class="boring">            double power = PIDF.calculate(linearSlides.getCurrentPosition(), targetPosition)
</span><span class="boring">            linearSlides.setPower(power);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We used a displacement marker, which tells Roadrunner to run this code at the specified position along the trajectory.
The <code>() -&gt; {}</code> is the lambda format for a one time use function.
The empty parentheses indicate that the function requires no arguments, and the curly braces denote the start of the function.
In this case, we're just setting the <code>targetPosition</code> variable, but this marker could include setting servo position, reading sensors, or anything else really.</p>
<pre><code class="language-java"><span class="boring">public class RoadRunnerPIDF extends LinearOpMode {
</span><span class="boring">    // the capitalization and snake_case is just convention because the values of an enum are constants
</span><span class="boring">    public enum STATES {
</span><span class="boring">        INIT,
</span><span class="boring">        DRIVE_FORWARD,
</span><span class="boring">        STRAFE_LEFT_AND_LIFT_SLIDES,
</span><span class="boring">        DRIVE_BACKWARD,
</span><span class="boring">        STOP;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    private STATES previousState = STATES.INIT;
</span><span class="boring">    private STATES currentState = STATES.INIT;
</span><span class="boring">    private int targetPosition = 0;
</span><span class="boring">
</span><span class="boring">    private TrajectorySequence forward;
</span><span class="boring">    private TrajectorySequence strafeLeft;
</span><span class="boring">    private TrajectorySequence backward;
</span><span class="boring">
</span><span class="boring">    private SampleMecanumDrive drive;
</span><span class="boring">    private DcMotorEx linearSlides;
</span><span class="boring">    private PIDFController PIDF;
</span><span class="boring">
</span><span class="boring">    public void runOpMode() {
</span><span class="boring">        /* for the purpose of this recipe, I will be using linear slides with PIDF control to demonstrate.
</span><span class="boring">        The linear slides will simply be called linearSlides.
</span><span class="boring">        */
</span><span class="boring">
</span><span class="boring">        // linear slide initialization code
</span><span class="boring">        // pidf initialization code
</span><span class="boring">
</span><span class="boring">        drive = new SampleMecanumDrive(hardwareMap);
</span><span class="boring">        drive.setPoseEstimate(new Pose2d());
</span><span class="boring">
</span><span class="boring">        forward = drive.TrajectorySequenceBuilder(new Pose2d())
</span><span class="boring">            .forward(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        strafeLeft = drive.TrajectorySequenceBuilder(forward.end())
</span><span class="boring">            .addDisplacementMarker(() -&gt; {
</span><span class="boring">                targetPosition = 800;
</span><span class="boring">            })
</span><span class="boring">            .strafeLeft(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        backward = drive.TrajectorySequenceBuilder(strafeLeft.end())
</span><span class="boring">            .back(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        waitForStart();
</span><span class="boring">
</span><span class="boring">        currentState = STATES.DRIVE_FORWARD;
</span><span class="boring">
</span><span class="boring">        while(opModeIsActive) {
</span><span class="boring">            switch (currentState) {
</span><span class="boring">                case (INIT):
</span><span class="boring">                    break;
</span>                case (DRIVE_FORWARD):
                    if (previousState != currentState) {
                        // everything in here will run once when the state switches

                        drive.followTrajectoryAsync(forward)
                        previousState = STATES.DRIVE_FORWARD;
                    } else if (!drive.isBusy()) {
                        currentState = STATES.STRAFE_LEFT_AND_LIFT_SLIDES;
                    }
                    break;
<span class="boring">                case (STRAFE_LEFT_AND_LIFT_SLIDES):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        // inside this trajectory sequence the targetPosition is set and the slides will start updating
</span><span class="boring">                        drive.followTrajectorySequenceAsync(strafeLeft);
</span><span class="boring">                    } else if (!drive.isBusy() &amp;&amp; linearSlides.atTarget()) {
</span><span class="boring">                        currentState = STATES.DRIVE_BACKWARD;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (DRIVE_BACKWARD):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        drive.followTrajectorySequenceAsync(backward);
</span><span class="boring">                        previousState = STATES.DRIVE_BACKWARD;
</span><span class="boring">                    } else if (!drive.isBusy()) {
</span><span class="boring">                        currentState = STATES.STOP;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (STOP):
</span><span class="boring">                    break;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            // outside of the switch we update our slides, that way they are always receiving new information
</span><span class="boring">            drive.update();
</span><span class="boring">            double power = PIDF.calculate(linearSlides.getCurrentPosition(), targetPosition)
</span><span class="boring">            linearSlides.setPower(power);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>So now we're getting to the Finite State Machine (FSM) part.
The first part of this case, which you'll see in each part, is checking whether previous and current states are equal.
This allows us to run code the first time it enters this state, like starting a trajectory (in this example).
Then inside that same block, we also need to set the previous state to the one we're in.</p>
<p>The <code>else if</code> just checks if we're done with this state to detect when to move on.
This is the transition trigger.
In this case, it detects when the Roadrunner trajectory finishes.</p>
<p>The next case is the more interesting one.</p>
<pre><code class="language-java"><span class="boring">public class RoadRunnerPIDF extends LinearOpMode {
</span><span class="boring">    // the capitalization and snake_case is just convention because the values of an enum are constants
</span><span class="boring">    public enum STATES {
</span><span class="boring">        INIT,
</span><span class="boring">        DRIVE_FORWARD,
</span><span class="boring">        STRAFE_LEFT_AND_LIFT_SLIDES,
</span><span class="boring">        DRIVE_BACKWARD,
</span><span class="boring">        STOP;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    private STATES previousState = STATES.INIT;
</span><span class="boring">    private STATES currentState = STATES.INIT;
</span><span class="boring">    private int targetPosition = 0;
</span><span class="boring">
</span><span class="boring">    private TrajectorySequence forward;
</span><span class="boring">    private TrajectorySequence strafeLeft;
</span><span class="boring">    private TrajectorySequence backward;
</span><span class="boring">
</span><span class="boring">    private SampleMecanumDrive drive;
</span><span class="boring">    private DcMotorEx linearSlides;
</span><span class="boring">    private PIDFController PIDF;
</span><span class="boring">
</span><span class="boring">    public void runOpMode() {
</span><span class="boring">        /* for the purpose of this recipe, I will be using linear slides with PIDF control to demonstrate.
</span><span class="boring">        The linear slides will simply be called linearSlides.
</span><span class="boring">        */
</span><span class="boring">
</span><span class="boring">        // linear slide initialization code
</span><span class="boring">        // pidf initialization code
</span><span class="boring">
</span><span class="boring">        drive = new SampleMecanumDrive(hardwareMap);
</span><span class="boring">        drive.setPoseEstimate(new Pose2d());
</span><span class="boring">
</span><span class="boring">        forward = drive.TrajectorySequenceBuilder(new Pose2d())
</span><span class="boring">            .forward(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        strafeLeft = drive.TrajectorySequenceBuilder(forward.end())
</span><span class="boring">            .addDisplacementMarker(() -&gt; {
</span><span class="boring">                targetPosition = 800;
</span><span class="boring">            })
</span><span class="boring">            .strafeLeft(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        backward = drive.TrajectorySequenceBuilder(strafeLeft.end())
</span><span class="boring">            .back(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        waitForStart();
</span><span class="boring">
</span><span class="boring">        currentState = STATES.DRIVE_FORWARD;
</span><span class="boring">
</span><span class="boring">        while(opModeIsActive) {
</span><span class="boring">            switch (currentState) {
</span><span class="boring">                case (INIT):
</span><span class="boring">                    break;
</span><span class="boring">                case (DRIVE_FORWARD):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        // everything in here will run once when the state switches
</span><span class="boring">
</span><span class="boring">                        drive.followTrajectoryAsync(forward)
</span><span class="boring">                        previousState = STATES.DRIVE_FORWARD;
</span><span class="boring">                    } else if (!drive.isBusy()) {
</span><span class="boring">                        currentState = STATES.STRAFE_LEFT_AND_LIFT_SLIDES;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span>                case (STRAFE_LEFT_AND_LIFT_SLIDES):
                    if (previousState != currentState) {
                        // inside this trajectory sequence the targetPosition is set and the slides will start updating
                        drive.followTrajectorySequenceAsync(strafeLeft);
                    } else if (!drive.isBusy() &amp;&amp; linearSlides.atTarget()) {
                        currentState = STATES.DRIVE_BACKWARD;
                    }
                    break;
<span class="boring">                case (DRIVE_BACKWARD):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        drive.followTrajectorySequenceAsync(backward);
</span><span class="boring">                        previousState = STATES.DRIVE_BACKWARD;
</span><span class="boring">                    } else if (!drive.isBusy()) {
</span><span class="boring">                        currentState = STATES.STOP;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (STOP):
</span><span class="boring">                    break;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            // outside of the switch we update our slides, that way they are always receiving new information
</span><span class="boring">            drive.update();
</span><span class="boring">            double power = PIDF.calculate(linearSlides.getCurrentPosition(), targetPosition)
</span><span class="boring">            linearSlides.setPower(power);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Here we have the same structure.
However, this time our transition trigger is finishing the Roadrunner trajectory and the linear slides reaching their target.
Because this runs in a loop, once the displacement marker triggers and changes the targetPosition, the PID update that runs at the end of every loop will move the linear slides accordingly.</p>
<p>It is also important to note that when using async following, you must call drive.update() once every loop.
This allows Roadrunner to track the robot's movement and to ensure the motors are following the trajectory.
Without it, the robot will not move.</p>
<p>Whew! You should now be able to integrate a PID(F) controller with Roadrunner trajectories.</p>
<p>This example was meant to be general and explain the structure and concepts needed to make PID(F) controllers work with Roadrunner.
It will almost certainly require changes to make it work exactly how you wish, so don't worry if your code doesn't look exactly like this example!</p>
<h3 id="state-factory"><a class="header" href="#state-factory">State Factory</a></h3>
<p><a href="https://state-factory.gitbook.io/state-factory/installation">State Factory</a> is a library which helps abstract a lot of the code of a finite state machine.
It also helps ensure you don't forget to write a break or an exit case.</p>
<p><em>This recipe will not cover the installation of State Factory.
Please follow the instructions on their gitbook to install it.</em></p>
<p>So, we're going to write the same finite state machine but this time using State Factory.</p>
<pre><code class="language-java">public class RoadRunnerPIDFSF extends LinearOpMode {

    public enum STATES {
        INIT,
        DRIVE_FORWARD,
        STRAFE_LEFT_AND_LIFT_SLIDES,
        DRIVE_BACKWARD,
        STOP;
    }

    SampleMecanumDrive drive;
    DcMotorEx linearSlides;
    PIDFController PIDF;
    int targetPosition = 0;

    public void runOpMode() {

        // all the same initialization and trajectory building as above

        StateMachine machine = new StateMachine()
            .state(STATES.INIT) // creates a new state
            .transition(() -&gt; isStarted()) // condition to transition from this state to the next one

            .state(STATES.DRIVE_FORWARD) // register a new state
            .onEnter(() -&gt; drive.followTrajectorySequenceAsync(forward)) // code to happen one time when entering this state
            .transition(() -&gt; !drive.isBusy())

            .state(STATES.STRAFE_LEFT_AND_LIFT_SLIDES)
            .onEnter(() -&gt; drive.followTrajectorySequenceAsync(strafeLeft))
            .transition(() -&gt; (!drive.isBusy() &amp;&amp; linearSlides.atTarget()))

            .state(STATES.DRIVE_BACKWARD)
            .onEnter(() -&gt; drive.followTrajectorySequenceAsync(backward))
            .transition(() -&gt; !drive.isBusy())

            .state(STATES.STOP)

            .build();
        // building this StateMachine doesn't actually do anything. We still need to run it

        waitForStart();

        machine.start(); // this starts the state machine, putting us into the first state

        while(opModeIsActive()) {
            machine.update();
            drive.update();
            double power = PIDF(linearSlides.getCurrentPosition(), targetPosition);
            linearSlides.setPower(power);
        }
    }
}
</code></pre>
<p>These two examples both do the exact same thing.
This introduction to State Factory was mostly meant to show how it can simplify writing FSMs.</p>
<p>Android studio may recommend changing something like <code>() -&gt; !drive.isBusy()</code> to <code>!drive::isBusy</code>.
These are simply two different ways to write the same thing.
The double colon works like <code>class/instance::method</code>.</p>
<p><strong>It is important to note that these were extremely simple FSMs and do not demonstrate their full capabilities.
This was simply meant to show you a way to integrate RoadRunner and a PIDF controller.</strong></p>
<p><em>Last Updated: 2024-01-23</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullpointerexception-on-initialization"><a class="header" href="#nullpointerexception-on-initialization"><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html"><code>NullPointerException</code></a> on initialization</a></h1>
<p>NullPointerExceptions are common errors that occur when code runs in the wrong order. Here, we will cover how and why NPEs happen in general, as well as some common FTC-specific issues.</p>
<h2 id="ingredients-5"><a class="header" href="#ingredients-5">Ingredients</a></h2>
<ol>
<li>A limited knowledge of Java.</li>
<li>A desire to learn, debug, or solve problems!</li>
</ol>
<h2 id="quick-links-common-issues"><a class="header" href="#quick-links-common-issues">Quick Links: Common Issues</a></h2>
<p><a href="common_ds_errors/npe_at_init/./npe_at_init.html#common-issues-hardware-devices-in-opmodes">Hardware Devices in OpModes</a>
<a href="common_ds_errors/npe_at_init/./npe_at_init.html#common-issues-hardware-devices-in-external-classes">Hardware Devices in External Classes</a>
<a href="common_ds_errors/npe_at_init/./npe_at_init.html#common-issues-blockscompanion-hardwaremap-and-telemetry">BlocksCompanion hardwareMap and telemetry</a></p>
<h2 id="the-recipe-2"><a class="header" href="#the-recipe-2">The Recipe</a></h2>
<h3 id="what-does-it-look-like"><a class="header" href="#what-does-it-look-like">What does it look like?</a></h3>
<p>The general format of the error is:</p>
<pre><code>java.lang.NullPointerException: Attempt to invoke [...] on a null object reference
</code></pre>
<p>On the Driver Station, you may see a stacktrace similar to this:</p>
<p><img src="common_ds_errors/npe_at_init/./npe_exception.jpg" alt="A stacktrace of the Driver Station with a NPE." /></p>
<div style="text-align: center;"><em>A stacktrace of the Driver Station with a NPE.</em></div>
<h3 id="why-does-this-happen"><a class="header" href="#why-does-this-happen">Why does this happen?</a></h3>
<p>First, we need to understand more about how Java works a little more in depth.</p>
<blockquote>
<p>This section is a little lengthy, feel free to scroll below for the solution.</p>
</blockquote>
<p>When we program in Java, we have expressions, which have a certain <strong>type</strong>.
The type tells us about the properties of said expression.</p>
<p>This lets us add <code>int</code>s, set the power of a <code>DcMotor</code>, or check if a <code>boolean</code> is true!</p>
<p>Type systems also give us a degree of validity; we can't add servos to booleans.</p>
<blockquote>
<p>The following is a very generalized description with oversights, but is sufficient for conceptual understanding.</p>
</blockquote>
<p>In Java, there are two categories of types:</p>
<ul>
<li>Primitive Types
<ul>
<li>Primitives are not objects, and do not have methods, only a value.</li>
<li>Primitives are passed by value.</li>
<li><code>int</code>, <code>double</code>, and <code>boolean</code>, are examples of primitives.</li>
</ul>
</li>
<li>Reference Types
<ul>
<li>All types that extend <code>Object</code> are passed by reference, and hence, reference types.</li>
<li>All objects are passed by reference.</li>
<li><code>class</code>es, <code>interface</code>s, <code>enum</code>s, arrays</li>
</ul>
</li>
</ul>
<blockquote>
<h4 id="what-does-it-mean-to-passstore-an-object-by-value-or-reference"><a class="header" href="#what-does-it-mean-to-passstore-an-object-by-value-or-reference"><strong>What does it mean to pass/store an object by value or reference?</strong></a></h4>
<p><strong>Storing by Value:</strong></p>
<ul>
<li>You are storing the actual value of the variable in memory.</li>
<li>This means that when you assign one variable to another, a copy of the value is made.</li>
<li>Changes to one variable do not affect the other.</li>
<li>
<pre><code class="language-java">int bobMoney = 20;
int jeffMoney = bobMoney; // "jeffMoney" gets the value of "bobMoney", not a reference to "bobMoney"

jeffMoney = 10; // changing "jeffMoney" does not affect "bobMoney"

System.out.println(bobMoney); // 20
</code></pre>
</li>
</ul>
<p><strong>Storing by Reference:</strong></p>
<ul>
<li>You are storing a reference or memory address to the location where the actual data is stored.</li>
<li>This means that when you assign one variable to another, they both point to the same memory location.</li>
<li>Changes to one variable will affect the other because they both refer to the same data.</li>
<li>
<pre><code class="language-java">Person bob = new Person("bob", 18);
Person anon = bob; // "anon" now refers to the same object as "bob"

System.out.println(bob.getAge()); // will print 18

anon.setAge(21); // changing "anon" also changes "bob"

System.out.println(bob.getAge()); // will print 21
</code></pre>
</li>
</ul>
</blockquote>
<p><code>null</code> really refers to a null <strong>reference</strong>. This means any <code>Object</code> can have a <code>null</code> value.</p>
<p>Any uninitialized <code>Object</code> has no reference to point to; a null reference, or <code>null</code>.
NPEs occur when you try to use the typed properties of an object while it points to nothing.
This is so no undefined behavior occurs.</p>
<p>Java does not provide any means of "null-safety", and so it is the responsibility of the programmer to check for and handle potential null values.</p>
<p>FTC specific examples include trying to access the <code>hardwareMap</code> at instantiation, or just never assigning a value to a <code>HardwareDevice</code>.</p>
<h3 id="hardwaremap-and-telemetry"><a class="header" href="#hardwaremap-and-telemetry">hardwareMap and telemetry</a></h3>
<p>It is important to note that NPEs are a very common, generic exception. However, the most common causes in FTC are due to the way <code>hardwareMap</code> and <code>telemetry</code>  work. This section will detail the way that <code>hardwareMap</code> and <code>telemetry</code> work, why it's so easy to get them wrong, and how to fix it.</p>
<p>Whenever you write an <code>OpMode</code>, you use the <code>telemetry</code> and <code>hardwareMap</code> objects all the time!</p>
<pre><code class="language-java">// Instantiate drive motors
DcMotor frontLeft = hardwareMap.get(DcMotor.class, "frontLeft");
</code></pre>
<p><em>A generic example of using <code>hardwareMap</code>.</em></p>
<p>However, these objects have to come from somewhere, and in fact they do! They are both created within the <code>OpMode</code> itself. This means that <strong>you cannot directly access <code>hardwareMap</code> OR <code>telemetry</code> from outside an OpMode.</strong> This is a very common issue, and typically the biggest cause of NullPointerExceptions.</p>
<p>There is actually even another layer to this - while <code>telemetry</code> can be accessed anywhere within the <code>OpMode</code>, <code>hardwareMap</code> must only be accessed after the <code>OpMode</code> has started running.</p>
<p><em>Technical details: <code>hardwareMap</code> and <code>telemetry</code> are both from <code>OpModeInternal</code> (which both <code>OpMode</code> and <code>LinearOpMode</code> inherit). <code>telemetry</code> is instantiated on class construction, whereas <code>hardwareMap</code> is instantiated as soon as the <code>OpMode</code> is run.</em></p>
<h3 id="common-issues-hardware-devices-in-opmodes"><a class="header" href="#common-issues-hardware-devices-in-opmodes">Common Issues: Hardware Devices in OpModes</a></h3>
<p>Hardware devices (anything that requires <code>hardwareMap</code>) are <strong>NOT</strong> accessible at class instantiation; that is, one <strong>cannot</strong> do the following:</p>
<pre><code class="language-java">@TeleOp
public class Testing extends OpMode {
  private DcMotor motor = hardwareMap.get(DcMotor.class, "motor"); // this will cause a NullPointerException because hardwareMap isn't defined until init()!

  @Override
  public void init() { } // it's always a red flag if the init is empty! TH=

  @Override
  public void loop() { 
    motor.setPower(1.0); 
  }
}
</code></pre>
<p>Hardware devices only start to become accessible during and after <code>init()</code> in <code>OpMode</code>s and within <code>runOpMode()</code> in <code>LinearOpMode</code>s.
Therefore, if you're using an <code>OpMode</code>, you should be instantiating (creating) your hardware devices in <code>init()</code>. In a <code>LinearOpMode</code>, hardware devices should be instatiated in <code>runOpMode()</code>, and before <code>waitForStart()</code>.</p>
<pre><code class="language-java">@TeleOp
public class Testing extends OpMode {
  private DcMotor motor;

  @Override
  public void init() {
    motor = hardwareMap.get(DcMotor.class, "motor"); // hardwareMap is defined here, so this won't cause an error!
    // any other hardware device instantiations should also go here
  }

  @Override
  public void loop() {
    motor.setPower(1.0); 
  }
}
</code></pre>
<h3 id="common-issues-hardware-devices-in-external-classes"><a class="header" href="#common-issues-hardware-devices-in-external-classes">Common Issues: Hardware Devices in External Classes</a></h3>
<p>Let's say you have a separate class where you want to access either <code>hardwareMap</code> or <code>telemetry</code>, or both. For example, we might have an <code>Arm</code> class that controls a simple rotating arm.</p>
<pre><code class="language-java">public class Arm {
  private DcMotor armMotor;

  /**
   * Tilts the arm using raw motor power.
   * @param power The motor power.
   */
  public void tilt(double power) {
    armMotor.setPower(power);
  }
}
</code></pre>
<p>Now, you might notice in the above code that the value of <code>armMotor</code> is never set to anything. This will cause a <code>NullPointerException</code>! To prevent this, we need to assign <code>armMotor</code> a value. Typically, we'd do this using <code>hardwareMap</code>. However, if you recall, <code>hardwareMap</code> isn't defined outside of <code>OpMode</code>s! So, what to do? Well, the idea is actually rather simple: when creating an <code>Arm</code>, we'll ask for an instance of <code>hardwareMap</code> that we can then use to define <code>armMotor</code>. Since <code>Arm</code> is created in an <code>OpMode</code>, <code>hardwareMap</code> will be defined!</p>
<pre><code class="language-java">public class Arm {
  private DcMotor armMotor;

  /**
   * @param hardwareMap The hardwareMap instance from an OpMode.
   */ 
  public Arm(HardwareMap hardwareMap) {
    armMotor = hardwareMap.get(DcMotor.class, "armMotor");
  }

  /**
   * Tilts the arm using raw motor power.
   * @param power The motor power.
   */
  public void tilt(double power) {
    armMotor.setPower(power);
  }
}
</code></pre>
<p>Now that we have our <code>Arm</code> class, this is what an <code>OpMode</code> would look like:</p>
<pre><code class="language-java">@TeleOp
public class ArmTest extends OpMode {
  private Arm arm;

  @Override
  public void init() {
    arm = new Arm(hardwareMap); // we still need to instantiate the arm in init(), since hardwareMap isn't defined before then
  }

  @Override
  public void loop() {
    arm.tilt(gamepad1.right_trigger - gamepad1.left_trigger); // use triggers to move arm up and down
  }
}
</code></pre>
<p>We can also do the same thing for <code>telemetry</code>:</p>
<pre><code class="language-java">private Telemetry telemetry;

public Arm(HardwareMap hardwareMap, Telemetry opModeTelemetry) {
  armMotor = hardwareMap.get(DcMotor.class, "armMotor");
  telemetry = opModeTelemetry;
}
</code></pre>
<p>...and we now have an <code>Arm</code> class that can access both <code>hardwareMap</code> and <code>telemetry</code>!</p>
<h3 id="common-issues-blockscompanion-hardwaremap-and-telemetry"><a class="header" href="#common-issues-blockscompanion-hardwaremap-and-telemetry">Common Issues: BlocksCompanion hardwareMap and telemetry</a></h3>
<p>Remember when we mentioned how <code>hardwareMap</code> and <code>telemetry</code> aren't defined outside of an <code>OpMode</code>? While this is true, there is still a way you can make your code <em>think</em> it can access <code>hardwareMap</code> and <code>telemetry</code>. Doing this will cause all of the NullPointerException problems with none of the helpful red squiggly lines.</p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode;

import static org.firstinspires.ftc.robotcore.external.BlocksOpModeCompanion.hardwareMap;
import static org.firstinspires.ftc.robotcore.external.BlocksOpModeCompanion.telemetry;

import com.qualcomm.robotcore.hardware.DcMotor;

public class Arm {
  private DcMotor armMotor;

  public Arm() {
    armMotor = hardwareMap.get(DcMotor.class, "armMotor");
  }

  /**
   * Tilts the arm using raw motor power.
   * @param power The motor power.
   */
  public void tilt(double power) {
    armMotor.setPower(power);
    telemetry.addData("Arm tilt power", power); // log tilt power in telemetry
  }
}
</code></pre>
<p>What's wrong here? You might notice how our constructor for <code>Arm</code> no longer has a parameter for <code>hardwareMap</code>, yet we can still use <code>hardwareMap</code> somehow! Similarly, we are also using <code>telemetry</code> without ever even defining it! This bug is incredibly sneaky. Normally, we don't pay a ton of attention to imports, but here the imports are exactly what matter. Let's isolate the important imports:</p>
<pre><code class="language-java">import static org.firstinspires.ftc.robotcore.external.BlocksOpModeCompanion.hardwareMap;
import static org.firstinspires.ftc.robotcore.external.BlocksOpModeCompanion.telemetry;
</code></pre>
<p>These two imports are incredibly nasty. The <code>hardwareMap</code> and <code>telemetry</code> above are not actually meant for us, but actually for Blocks users! This is, behind the scenes, what Blocks OpModes use. Since we are not using Blocks, these imports don't work. Luckily, although the bug is nasty, the solution is rather simple - get rid of the imports and pass <code>hardwareMap</code> and <code>telemetry</code> in like we did in the previous section!</p>
<p><em>Last updated: 2024-11-27</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-a-custom-pidf-controller"><a class="header" href="#integrating-a-custom-pidf-controller">Integrating a Custom PID(F) Controller</a></h1>
<p><em>This recipe does not cover usage for Roadrunner or Command-Based structures.</em></p>
<p><a href="https://www.ctrlaltftc.com/the-pid-controller">PID(F) controllers</a> are some of the most used controllers in FTC.
However, it can be confusing and challenging to properly integrate them into your OpModes.
This recipe will go over an example of how to integrate a PID(F) controller alongside a manual control system.</p>
<h2 id="ingredients-6"><a class="header" href="#ingredients-6">Ingredients</a></h2>
<ol>
<li>A PID or PIDF controller class (this should be a file that is something like PIDFController.java, or you may use a pre-made one from a library like FTCLib).</li>
<li>A use case for the PID(F).</li>
<li>An OpMode or LinearOpMode.</li>
</ol>
<h2 id="the-recipe-3"><a class="header" href="#the-recipe-3">The Recipe</a></h2>
<h3 id="creating-a-pidf-controller"><a class="header" href="#creating-a-pidf-controller">Creating a PID(F) Controller</a></h3>
<p>The first part of using a PID(F) controller is creating one.
To do this, we need to declare the PID(F) controller within the OpMode:</p>
<pre><code class="language-java">package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode; // This example is for a LinearOpMode, though a similar idea applies to regular OpModes.
import org.firstinspires.ftc.teamcode.controllers.PIDController; // This may vary depending on what implementation you are using.
import org.firstinspires.ftc.teamcode.controllers.PIDFController; // This may vary depending on what implementation you are using.

@TeleOp
public class ExampleOpMode extends LinearOpMode {

    // This line creates a PIDF controller named examplePIDF that has coefficients of:
    // kP = 0
    // kI = 0
    // kD = 0
    // kF = 0
    private PIDFController examplePIDF = new PIDFController(0, 0, 0, 0);

    // This line creates a PID controller named examplePID that has coefficients of:
    // kP = 0
    // kI = 0
    // kD = 0
    private PIDController examplePID = new PIDController(0, 0, 0);

    @Override
    public void runOpMode() {
        // OpMode code goes here
    }

}
</code></pre>
<p>Now that we have our PID(F) controller, we need to use it!
One of the most common use cases for a PID(F) controller is moving a motor to a certain motor encoder position.
As an example, let's say we have a linear slide, and want to move it to 500 ticks when we press "a."
We also want to be able to move it up and down using the triggers.
The following code is for a LinearOpMode (the <code>while (opModeIsActive())</code> section would go in the <code>loop()</code> function for a OpMode):</p>
<pre><code class="language-java">

public void runOpMode() {
    // Put all of your initialization here.
    DcMotor slides = hardwareMap.dcMotor.get("slides");
    waitForStart();

    int targetPosition = 500;

    // We will use this variable to determine if we want the PIDF to run.
    boolean usePIDF = false;

    Gamepad lastGamepad1 = new Gamepad();
    Gamepad lastGamepad2 = new Gamepad();

    while (opModeIsActive()) {

        // This is a rising-edge detector that runs if and only if "a" was pressed this loop.
        if (gamepad1.a &amp;&amp; !lastGamepad1.a) {
            usePIDF = true;
        }


        if (gamepad1.left_trigger &gt; 0) {
            slides.setPower(gamepad1.left_trigger);

            // If we get any sort of manual input, turn PIDF off.
            usePIDF = false;
        } else if (gamepad1.right_trigger &gt; 0) {
            slides.setPower(gamepad1.right_trigger);

             // If we get any sort of manual input, turn PIDF off.
            usePIDF = false;
        } else if (usePIDF) {
            // Sets the slide motor power according to the PIDF output.
            slides.setPower(examplePIDF.calculate(slides.getCurrentPosition(), targetPosition));
        }
    }
}


</code></pre>
<p>This is a lot, so let's break it down piece by piece.
First, we initialize our slide motor, which we call <code>slides</code>.</p>
<pre><code class="language-java">DcMotor slides = hardwareMap.dcMotor.get("slides");
</code></pre>
<p>Next, we wait for the program to start and declare some variables.</p>
<pre><code class="language-java">waitForStart();

int targetPosition = 500;

// We will use this variable to determine if we want the PIDF to run.
boolean usePIDF = false;

Gamepad lastGamepad1 = new Gamepad();
Gamepad lastGamepad2 = new Gamepad();
</code></pre>
<p><code>targetPosition</code> is simply the position we want the slides to go to, which is 500.
<code>usePIDF</code> stores the state of our system, i.e. whether we want to run the PIDF or use manual control.
<code>lastGamepad1</code> and <code>lastGamepad2</code> are used for <a href="https://gm0.org/en/latest/docs/software/tutorials/gamepad.html?detector#rising-edge-detector">Rising Edge Detectors</a>.
In short, they detect when a button begins to be pressed, and ignore when it is held.</p>
<p>The next part is the while loop, which ensures that the code runs in a loop until the OpMode stops.</p>
<pre><code class="language-java">while (opModeIsActive())
</code></pre>
<p>We then use a <a href="https://gm0.org/en/latest/docs/software/tutorials/gamepad.html?detector#rising-edge-detector">Rising Edge Detector</a> to check if "a" was just pressed.
If it was, we set <code>usePIDF</code> to true to tell the program to move to the target position.</p>
<pre><code class="language-java">// This is a rising-edge detector that runs if and only if "a" was pressed this loop.
if (gamepad1.a &amp;&amp; !lastGamepad1.a) {
    usePIDF = true;
}
</code></pre>
<p>The next part is a little complicated, but the idea is that we only want to call <code>slide.setPower()</code> once, so we group all the ways it can be called together so that they can't happen at the same time.</p>
<p>First, we check if the left trigger is pressed.
If it is, we set the slide power to an appropriate value and switch to manual control mode by setting <code>usePIDF</code> to <code>false</code>.</p>
<pre><code class="language-java">if (gamepad1.left_trigger &gt; 0) {
    slides.setPower(gamepad1.left_trigger);

    // If we get any sort of manual input, turn PIDF off.
    usePIDF = false;
}
</code></pre>
<p>Next, we do the same check, but for the right trigger.</p>
<pre><code class="language-java">else if (gamepad1.right_trigger &gt; 0) {
    slides.setPower(gamepad1.right_trigger);

        // If we get any sort of manual input, turn PIDF off.
    usePIDF = false;
}
</code></pre>
<p>Note that we use <code>else</code> to only run this code if the left trigger is not pressed.
This prevents pressing both triggers at the same time from causing any issues.</p>
<p><strong>Tip:</strong> If your triggers return nonzero values even when they are not being pressed, you can increase the minimum value (the <code>0</code> in the statement <code>if (gamepad1.left_trigger &gt; 0)</code>) from <code>0</code> to something like <code>0.1</code>.</p>
<p>Finally, if there are no manual inputs, and we are in the PID(F) state, we run the PID(F).</p>
<pre><code class="language-java">else if (usePIDF) {
    // Sets the slide motor power according to the PIDF output.
    slides.setPower(examplePIDF.calculate(slides.getCurrentPosition(), targetPosition));
}
</code></pre>
<p>This is a pretty standard way of using the PID(F) output to set a motor power.
<code>slides.getCurrentPosition()</code>, as the name implies, just returns the current slide position, in ticks.
The <a href="https://ftclib.org/"><em>FTCLib</em></a> PID(F) assumes that the first input of the function is the place where your motor is, and the second input is the place where your motor wants to be.
We will be using the <em>FTCLib</em> PID(F) syntax here for the sake of having some standard, but either way works.</p>
<p>If you've read through this entire thing, then congrats!
You should now have a fully functioning PID(F) controller that you can implement anywhere, even in conjunction with manual control.</p>
<p>Note that the example we went through is just one way PID(F)s can be used, and there are many ways to achieve this result.
Don't worry if your code doesn't look exactly like this example!</p>
<p>As an aside, the technique we used to make sure the PID(F) control and manual control did not interfere is a simple version of what's known as a <a href="https://gm0.org/en/latest/docs/software/concepts/finite-state-machines.html"><strong>Finite State Machine</strong></a>.
This idea of having multiple possible states and only running one at a time to ensure they don't interfere can be used for much more complex systems, such as controlling an entire Autonomous!</p>
<p>Best of luck with your code!</p>
<p><em>Last updated: 2024-05-29</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syncing-two-linear-slide-motors-using-a-pidf-controller"><a class="header" href="#syncing-two-linear-slide-motors-using-a-pidf-controller">Syncing Two Linear Slide Motors Using a PIDF Controller</a></h1>
<h3 id="ingredients-7"><a class="header" href="#ingredients-7">Ingredients</a></h3>
<ol>
<li>A PID(F) controller</li>
<li>Tuned PID(F) coefficients</li>
</ol>
<h2 id="the-recipe-4"><a class="header" href="#the-recipe-4">The Recipe</a></h2>
<h3 id="the-problem-2"><a class="header" href="#the-problem-2">The Problem</a></h3>
<p>Linear slides powered by two different motors can end up twisted, with one slide higher than the other.
This can happen if the two encoders get out of sync.
If you are using the RUN_TO_POSITION motor mode, this causes one slide to be supplied more power than the other.
Even if you are using a custom PID(F) controller on each motor, the same problem would occur.</p>
<h3 id="methodology"><a class="header" href="#methodology">Methodology</a></h3>
<p><strong>The BEST way to keep these in sync is to have them be mechanically connected with a bar or a piece of channel.
If the two act as one rigid body, then it is a lot less dependent on software.
However, this is not always possible, hence the software solutions.</strong></p>
<p>Instead, the way this recipe will explain is with a leader and a follower linear slide motor.
This means we will use a PID(F) controller on one of the linear slide positions and just set that power to both motors.
This resolves the issue of the two linear slides being supplied different powers.
If both motors are going the same speed and both linear slides are well tensioned, the linear slides should stay synced.</p>
<h3 id="code-example"><a class="header" href="#code-example">Code Example</a></h3>
<p>This code example is going to assume you have a working PID(F) controller class and tuned coefficients.</p>
<pre><code class="language-java"><span class="boring">public class PIDFExample extends LinearOpMode {
</span><span class="boring">
</span>    // PID(F) declaration
    // kp = 0, ki = 0, kd = 0, kf = 0;

    private PIDFController examplePIDF = new PIDFController(0, 0, 0, 0);

    @Override
    public void runOpMode() {
        int targetPosition = 0;

        // motor setup
        DcMotorEx leftSlide = hardwareMap.get(DcMotorEx.class, "leftSlide");
        DcMotorEx rightSlide = hardwareMap.get(DcMotorEx.class, "rightSlide");

        waitForStart();

        while(opModeIsActive()) {
            /* 
            Calculates PID based only on one encoder.
            This can also be the average position of the two linear slides, but we haven't noticed much difference
            */
            double power = PIDFController.update(leftSlide.getCurrentPosition(), targetPosition);

            // see how both motors are getting the same power
            leftSlide.setPower(power);
            rightSlide.setPower(power);
        }
    }
<span class="boring">
</span><span class="boring">}
</span></code></pre>
<p><em>Last Updated: 2024-05-29</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-to-only-use-usb-30"><a class="header" href="#why-to-only-use-usb-30">Why to only use USB 3.0</a></h1>
<h3 id="ingredients-8"><a class="header" href="#ingredients-8">Ingredients</a></h3>
<ol>
<li>A Control Hub</li>
<li>At least 1 USB device</li>
<li>A USB hub (optional)</li>
</ol>
<h2 id="the-recipe-5"><a class="header" href="#the-recipe-5">The Recipe</a></h2>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<p>The Control Hub has a lot of nuances that many people do not know of, including the dangers of the onboard USB 2.0 port.</p>
<h3 id="the-problem-3"><a class="header" href="#the-problem-3">The Problem</a></h3>
<p>The Control Hub's USB 2.0 port shares a ground with the Wi-Fi chipset on the Control Hub.
This provides a path for a static shock to the USB device to cause a Wi-Fi disconnect mid-match.</p>
<h3 id="how-to-mitigate-the-problem"><a class="header" href="#how-to-mitigate-the-problem">How to Mitigate the Problem</a></h3>
<p>The best way to mitigate the problem is to not use the USB 2.0 port on your Control Hub.
For teams with no or only one USB device, that's not a problem, just use the USB 3.0 port instead of the USB 2.0 port.
If your team needs more than one device, such as an Expansion Hub over USB <em>and</em> a USB camera for object detection, it gets more complicated.
To prevent shock, you can get a USB hub and connect all devices through just the USB 3.0 port.</p>
<p><em>Last Updated: 2024-05-29</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-wire-odometry-pods"><a class="header" href="#how-to-wire-odometry-pods">How to wire odometry pods</a></h1>
<h3 id="ingredients-9"><a class="header" href="#ingredients-9">Ingredients</a></h3>
<ol>
<li>An Expansion Hub or Control Hub</li>
<li>either 2 or 3 odometry pods/modules</li>
</ol>
<h2 id="the-recipe-6"><a class="header" href="#the-recipe-6">The Recipe</a></h2>
<h3 id="the-problem-4"><a class="header" href="#the-problem-4">The problem</a></h3>
<p>The Rev Control Hub and Expansion Hub, as found <a href="https://blog.eeshwark.com/robotblog/rev-hub-quadrature">here</a> by 7244 alum Eeshwar, only have 2 reliable quadrature encoder ports.
This means high CPR/PPR encoders such as the Rev Through Bore encoder will miss counts on ports 1 and 2 which will lead to drift.</p>
<h3 id="solutions"><a class="header" href="#solutions">Solutions</a></h3>
<h3 id="2-wheel-odometry"><a class="header" href="#2-wheel-odometry">2 Wheel Odometry</a></h3>
<p>For teams that use a 2 wheel + IMU setup, the solution is simple!
Put the drive motors on the Control Hub.
Then, as you don't need drive encoders, you can simply put the odometry on Control Hub encoder ports 0 and 3 where you would usually put the motor encoders.</p>
<h3 id="3-wheel-odometry"><a class="header" href="#3-wheel-odometry">3 Wheel Odometry</a></h3>
<p>For teams with 3 wheel odometry, it is a bit more complex.
The most important odometry pods are the parallel ones since encoder drift with them will cause heading drift.
This can rapidly ruin your localization as heading is used as a basis for all other measurements.
Since they're the most important, the parallel pods should go in ports 0 and 3 on the Control Hub.
The perpendicular (strafe) pod is less important to localization, so it is fine to put it in port 1 or 2 on the Control Hub.</p>
<p>Note that you should always put odometry on the Control Hub (or at least all on the same hub) even if you must place it in ports 1 or 2.
This is because reading from the Expansion Hub requires an additional bulk read.
This can greatly worsen loop times and is not worth the benefits of using the 0 and 3 ports.</p>
<p><em>Last Updated: 2024-05-29</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-do-some-ftc-programmers-use-kotlin-should-i-switch"><a class="header" href="#why-do-some-ftc-programmers-use-kotlin-should-i-switch">Why do some FTC programmers use Kotlin? Should I switch?</a></h1>
<p><em>Have you ever seen Kotlin mentioned in the context of FTC code?</em></p>
<p><em>Are you curious about why some FTC programmers like to use Kotlin for their code bases?</em></p>
<p>Kotlin is a language with very high cross-compatability with Java, which means it can be used to write your FTC code.</p>
<p>FIRST provides official instructions
for adding Kotlin to your project <a href="https://ftc-docs.firstinspires.org/en/latest/programming_resources/shared/installing_kotlin/Installing-Kotlin.html">here.</a></p>
<h2 id="ingredients-10"><a class="header" href="#ingredients-10">Ingredients</a></h2>
<ol>
<li>Good understanding of Java</li>
<li>Interest in learning and exploring Kotlin</li>
</ol>
<h2 id="the-recipe-7"><a class="header" href="#the-recipe-7">The Recipe</a></h2>
<p>Kotlin is a language that makes a very solid attempt at modernizing Java.
It makes writing common Java patterns concise.
Kotlin also makes it easy to write safer code that is less likely to have strange bugs or throw confusing NullPointerExceptions.</p>
<p>Kotlin is unlikely to be particularly useful to you if you are not using Object-Oriented aspects of Java already.
If you are just writing [Linear]OpModes but are not writing your own classes, Kotlin is probably not for you.
While Kotlin certainly does offer some nice features in this environment, the challenges that come with using Kotlin may also prove hard to overcome unless you are writing more complex and involved code.
It is also advisable not to try to switch to Kotlin at the same time as learning more Object-Oriented skills.</p>
<p>Due to Kotlin's concise nature, it can sometimes prove difficult to read.
Java likes to put everything out in the open and be very direct and specific, while Kotlin tends to imply much more.</p>
<p>This recipe will cover some basics of Kotlin syntax with direct comparisons to Java.</p>
<h3 id="vars-and-vals"><a class="header" href="#vars-and-vals">Vars and Vals</a></h3>
<p>A big part of Kotlin is its changes to fields, getters, setters, and how they interact with parameters from constructors.</p>
<p>The following two snippets are effectively equivalent:</p>
<pre><code class="language-kt"><span class="boring">class VarsAndVals {
</span>	var var1 = 0
	private var var2 = "variable string"

	val val1 = 0
	private val val2 = "value string"
<span class="boring">
</span><span class="boring">	fun getting() {
</span><span class="boring">		val local1 = var1
</span><span class="boring">		val local2 = var2
</span><span class="boring">
</span><span class="boring">		val local3 = val1
</span><span class="boring">		val local4 = val2
</span><span class="boring">	}
</span><span class="boring">
</span><span class="boring">	fun setting() {
</span><span class="boring">		var1 = 100
</span><span class="boring">		var2 = "new value"
</span><span class="boring">	}
</span><span class="boring">}
</span></code></pre>
<pre><code class="language-java"><span class="boring">public class VarsAndVals {
</span>	private int var1 = 0;
	private String var2 = "variable string";
	
	private final int val1 = 0;
	private final String val2 = "value string";
	
	public int getVar1() {
		return var1;
	}
	
	public void setVar1(int var1) {
		this.var1 = var1;
	}
	
	private String getVar2() {
		return var2;
	}
	
	private void setVar2(String string) {
		this.var2 = string;
	}
	
	public int getVal1() {
		return val1;
	}
	
	private String getVar2() {
		return var2;
	}
<span class="boring">	
</span><span class="boring">	public void getting() {
</span><span class="boring">		final int local1 = getVar1();
</span><span class="boring">		final String local2 = getVar2();
</span><span class="boring">		
</span><span class="boring">		final int local3 = getVal1();
</span><span class="boring">		final String local4 = getVal2();
</span><span class="boring">	}
</span><span class="boring">	
</span><span class="boring">	public void setting() {
</span><span class="boring">		setVar1(100);
</span><span class="boring">		setVar2("new value");
</span><span class="boring">	}
</span><span class="boring">}
</span></code></pre>
<p>It's pretty clear that Kotlin saves a lot of work on the front of writing getters and setters.
While this isn't too big of a deal, Kotlin makes itself invaluable in enforcing the usage of these functions in a syntactically shorter manner.</p>
<pre><code class="language-kt"><span class="boring">class VarsAndVals {
</span><span class="boring">	var var1 = 0
</span><span class="boring">	private var var2 = "variable string"
</span><span class="boring">
</span><span class="boring">	val val1 = 0
</span><span class="boring">	private val val2 = "value string"
</span><span class="boring">
</span>	fun getting() {
		val local1 = var1
		val local2 = var2

		val local3 = val1
		val local4 = val2
	}

	fun setting() {
		var1 = 100
		var2 = "new value"
	}
<span class="boring">}
</span></code></pre>
<pre><code class="language-java"><span class="boring">public class VarsAndVals {
</span><span class="boring">	private int var1 = 0;
</span><span class="boring">	private String var2 = "variable string";
</span><span class="boring">	
</span><span class="boring">	private final int val1 = 0;
</span><span class="boring">	private final String val2 = "value string";
</span><span class="boring">	
</span><span class="boring">	public int getVar1() {
</span><span class="boring">		return var1;
</span><span class="boring">	}
</span><span class="boring">	
</span><span class="boring">	public void setVar1(int var1) {
</span><span class="boring">		this.var1 = var1;
</span><span class="boring">	}
</span><span class="boring">	
</span><span class="boring">	private String getVar2() {
</span><span class="boring">		return var2;
</span><span class="boring">	}
</span><span class="boring">	
</span><span class="boring">	private void setVar2(String string) {
</span><span class="boring">		this.var2 = string;
</span><span class="boring">	}
</span><span class="boring">	
</span><span class="boring">	public int getVal1() {
</span><span class="boring">		return val1;
</span><span class="boring">	}
</span><span class="boring">	
</span><span class="boring">	private String getVar2() {
</span><span class="boring">		return var2;
</span><span class="boring">	}
</span><span class="boring">	
</span>	public void getting() {
		final int local1 = getVar1();
		final String local2 = getVar2();
		
		final int local3 = getVal1();
		final String local4 = getVal2();
	}
	
	public void setting() {
		setVar1(100);
		setVar2("new value");
	}
<span class="boring">}
</span></code></pre>
<p>Kotlin enforces the use of getters and setters for property access, but uses the property access syntax!</p>
<p>Already, our Kotlin code is ~2.5 times shorter than Java.</p>
<p>If you're worried about defining custom getters and setters, Kotlin allows that too.
More detail is available in the <a href="https://kotlinlang.org/docs/properties.html#getters-and-setters">Kotlin docs</a>.
Kotlin allows for a fairly wide range of cool features around this concept.</p>
<h3 id="storing-constructor-parameters"><a class="header" href="#storing-constructor-parameters">Storing Constructor Parameters</a></h3>
<p>Kotlin makes it super easy to take in constructor parameters and store them in the class.
The following two snippets are also equivalent:</p>
<pre><code class="language-kt">class ConstructorParams (val val1: String, var var1: Int)
</code></pre>
<pre><code class="language-java">public class ConstructorParams {
	private final String val1;
	private int var1;
	
	public ConstructorParams(String val1, int var1) {
		this.val1 = val1;
		this.var1 = var1;
	}
	
	public int getVar1() {
		return var1;
	}
	
	public String getVal1() {
		return val1;
	}
	
	public void setVar1(int var1) {
		this.var1 = var1;
	}
}
</code></pre>
<p>In this case, what was numerous lines in Java is only one in Kotlin.
The Kotlin version is even a little easier to read!</p>
<h3 id="default-values-in-methods-and-constructors"><a class="header" href="#default-values-in-methods-and-constructors">Default Values In Methods and Constructors</a></h3>
<p>Kotlin makes it easy to specify default values to functions and constructors.
The following two snippets are equivalent:</p>
<pre><code class="language-kt">class DefaultValues {
	fun function(arg: Int = 0) {
		val a = arg + 10
	}
}
</code></pre>
<pre><code class="language-java">public class DefaultValues {
	public void function(int arg) {
		int a = arg + 10;
	}
	
	public void function() {
		function(0);
	}
}
</code></pre>
<p>Kotlin makes this a little more powerful than demonstrated here, but for most situations, this is pretty straightforward.</p>
<h3 id="null-safety"><a class="header" href="#null-safety">Null Safety</a></h3>
<p>Kotlin makes it easy to work with values that can and can't be null, much easier than Java:</p>
<pre><code class="language-kt">val neverNull: Int = 10
val nullable: Int? = null
</code></pre>
<p>The <code>?</code> lets us know that the variable could be null, and Kotlin will throw compilation warnings if we try to use it without checking and handling it.</p>
<p>Some more examples:</p>
<pre><code class="language-kt">fun addOrThrow(a: Int?, b: Int?) {
    val safeA = a ?: throw IllegalStateException("a is null")
    val safeB = b!!
    return safeA + safeB
}
</code></pre>
<p>The <code>?:</code> operator is known as the Elvis operator (after it's resemblance to Elvis Presley) and means that the code after it gets run only if the left-hand side is null.
This allows the function to immediately exit and throw an error before any further processing occurs.</p>
<p>The <code>!!</code> operator is a shortcut for this operation.
The Elvis operator is more powerful and flexible, but if you don't want to throw a specific error and instead crash immediately, the <code>!!</code> operator will enforce that the value isn't null.</p>
<p>Finally:</p>
<pre><code class="language-kt">fun nullSafeMethodCall(a: Int?): Double {
    return a?.toDouble() ?: throw IllegalStateException("a is null")
}
</code></pre>
<p>We combine the concept above with the <code>?.</code> operator, which performs a null safe method call.
If <code>a</code> is null, Kotlin won't try to call <code>.toDouble()</code> on it and will just return null,
which will then be caught by the Elvis operator!</p>
<h3 id="accessing-hardware"><a class="header" href="#accessing-hardware">Accessing Hardware</a></h3>
<p>Because of Kotlin's null safety system, accessing hardware must be done differently.
There are a few ways to do this, but the one we'll show here is to use <code>by lazy</code>:</p>
<pre><code class="language-kt">    // by lazy will only initialize this variable the first time it is used.
    // This prevents it from ever being null, but also allows you to initialize it only after your opmode begins.
    val arm by lazy { hardwareMap["arm"] as DcMotorEx } // Alternately hardwareMap.get(DcMotorEx::class.java, "arm") also works here

    override fun init() { // or runOpMode() for LinearOpModes
        // Since we used by lazy, accessing the arm in any way will automatically initialize it:
        arm.power = 1.0
        telemetry.addData("armPos", arm.currentPosition)
        telemetry.update()
        // Note that, since we used by lazy, we do NOT need to put !! after arm.
    }
</code></pre>
<p>There are other options to do this as well such as the <code>lateinit</code> keyword.</p>
<h3 id="overview-1"><a class="header" href="#overview-1">Overview</a></h3>
<p>Kotlin has a lot more to it than this short overview, but these are some of the features that make a big common difference with Java.
Hopefully, this arms you with an expectation of what the rest of Kotlin is like, and some of the reasons that more advanced FTC programmers like to choose it over Java.</p>
<p><a href="https://kotlinlang.org/docs/home.html">Kotlin official documentation</a></p>
<p>Overall, the best way to learn is just to jump in and give it a try.
If you get stuck, search it up, or take a look at the <a href="https://kotlinlang.org/docs/home.html">docs</a> again!</p>
<p>If you feel like you need a complete example of using Kotlin for FTC, I advise you ask in the FTC Discord.
Most people who use Kotlin write fairly complex codebases and use different combinations of libraries, so you might need to ask some questions to find an example relevant to you.</p>
<p>Another good place to search for Kotlin code in an FTC context is in libraries.
Many FTC software libraries such as <a href="https://github.com/acmerobotics/road-runner">Roadrunner</a> are written in Kotlin, so they can provide great usage examples.</p>
<p><em>Last updated: 2024-05-29</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acronyms"><a class="header" href="#acronyms">Acronyms</a></h1>
<h2 id="hardware-and-electronics"><a class="header" href="#hardware-and-electronics">Hardware and Electronics</a></h2>
<p><strong>CHub</strong>: Control Hub<br>
<strong>EHub/ExHub</strong>: Expansion Hub<br>
<strong>DS</strong>: Driver Station<br>
<strong>RC</strong>: Robot Controller<br>
<strong>ESD</strong>: Electrostatic Discharge<br>
<strong>DC</strong>: Disconnect</p>
<h2 id="sdk-built-in"><a class="header" href="#sdk-built-in">SDK Built-In</a></h2>
<p><strong>SDK</strong>: <a href="https://github.com/FIRST-Tech-Challenge/FtcRobotController">Standard Development Kit</a><br>
<strong>RTP</strong>: RUN_TO_POSITION Motor Mode<br>
<strong>RUE</strong>: RUN_USING_ENCODERS Motor Mode<br>
<strong>IMU</strong>: <a href="https://ftc-docs.firstinspires.org/en/latest/programming_resources/imu/imu.html">Internal Measurement Unit (Gyroscope)</a><br>
<strong>EOCV/OCV</strong>: Easy OpenCV/OpenCV | <a href="https://ftc-docs.firstinspires.org/en/latest/apriltag/vision_portal/visionportal_overview/visionportal-overview.html">Vision Processor</a>, <a href="https://github.com/OpenFTC/EasyOpenCV">Pipelines</a><br>
<strong>TFOD</strong>: <a href="https://ftc-docs.firstinspires.org/en/latest/programming_resources/index.html#tensorflow-programming">TensorFlow Object Detection</a><br>
<strong>hmap/hwmap</strong>: HardwareMap</p>
<h2 id="libraries"><a class="header" href="#libraries">Libraries</a></h2>
<p><strong>RR</strong>: RoadRunner (Motion Planning Library) <a href="https://learnroadrunner.com/">0.5.6</a>, <a href="https://rr.brott.dev/docs/v1-0/installation/">1.0</a></p>
<h2 id="controllers"><a class="header" href="#controllers">Controllers+</a></h2>
<p><strong>Odo</strong>: <a href="https://gm0.org/en/latest/docs/software/concepts/odometry.html?highlight=odometry">Odometry</a><br>
<strong>MP</strong>: <a href="https://www.ctrlaltftc.com/advanced/motion-profiling">Motion Profiling</a><br>
<strong>FF</strong>: <a href="https://www.ctrlaltftc.com/feedforward-control">FeedForward</a><br>
<strong>PID(F)</strong>: <a href="https://www.ctrlaltftc.com/the-pid-controller">Proportional Integral Derivative FeedForward Controller</a><br>
<strong>KF/EKF</strong>: <a href="https://www.ctrlaltftc.com/advanced/the-kalman-filter">Kalman Filter / Extended Kalman Filter</a></p>
<h2 id="other"><a class="header" href="#other">Other</a></h2>
<p><strong>GH</strong>: <a href="https://github.com/">GitHub</a><br>
<strong>AS</strong>: <a href="https://developer.android.com/studio">Android Studio</a><br>
<strong>OBJ</strong>: <a href="https://ftc-docs.firstinspires.org/en/latest/programming_resources/onbot_java/OnBot-Java-Tutorial.html">OnBot Java</a><br>
<strong>ADB</strong>: <a href="https://developer.android.com/tools/adb">Android Debug Bridge (used to wireless connect to control hub)</a></p>
<p><em>Last Updated: 2024-01-26</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="improving-loop-times"><a class="header" href="#improving-loop-times">Improving Loop Times</a></h1>
<h2 id="recipe-1"><a class="header" href="#recipe-1">Recipe</a></h2>
<p><strong>This recipe will cover various methods to improve loop times. At the end there are full examples of code that combine these methods</strong></p>
<h3 id="why-are-fast-loop-times-important"><a class="header" href="#why-are-fast-loop-times-important">Why are fast loop times important?</a></h3>
<p>The more often your teleop is updated, the more responsive it will be to button clicks and joystick changes.
This can make driving easier.
Additionally, if you are using PID(F) controllers, the more frequently they update the more accurate they are and the less they oscillate.</p>
<h3 id="what-causes-slow-loop-times"><a class="header" href="#what-causes-slow-loop-times">What causes slow loop times?</a></h3>
<p>Surprisingly, the main cause of slow loop times is not processing difficulties or code complexity.
Most of the processing time is spent on communicating with hardware devices, known as hardware "reads" and hardware "writes".</p>
<p>Hardware reads are when you are receiving data.
For example, getting an encoder position, reading a color sensor, or accessing the IMU are all hardware reads.
On the other hand, hardware writes are when you are sending data.
For example, setting a motor power, setting a servo position, or configuring an LED are all hardware writes.</p>
<h3 id="checking-loop-times"><a class="header" href="#checking-loop-times">Checking loop times</a></h3>
<p>Here is some basic code to measure your loop times in milliseconds.
The more milliseconds your loop takes, the slower your loop times are.</p>
<p>This measures looptimes over a single loop, which can lead to unstable readings,
but is good enough.</p>
<pre><code class="language-java"><span class="boring">package org.firstinspires.ftc.teamcode;
</span><span class="boring">
</span><span class="boring">import com.qualcomm.robotcore.eventloop.opmode.OpMode;
</span><span class="boring">import com.qualcomm.robotcore.util.ElapsedTime;
</span><span class="boring">
</span>public class MeasuringLoopTimes extends OpMode {
	private ElapsedTime elapsedtime;

	@Override
	public void init() {
		elapsedtime = new ElapsedTime();
		elapsedtime.reset();
	}

	@Override
	public void loop() {

		telemetry.addData("Loop Times", elapsedtime.milliseconds());
		elapsedtime.reset();
	}
}

</code></pre>
<p>You may want to try:</p>
<ul>
<li>Average looptimes over the whole runtime (totalRuntime / numberOfLoops).</li>
<li>Measuring looptimes over a window (over 100 loops, over 50 loops, etc).</li>
</ul>
<p>In order to get a better idea of your stable loop times.</p>
<p>Some of the optimisations we look at may increase the looptime variance, as some
loops may be very short, while others may be much longer.</p>
<h3 id="bulk-reading"><a class="header" href="#bulk-reading">Bulk Reading</a></h3>
<p>Other than I2C devices, reading can be done all at once in a "bulk read" for a huge loop time improvement.</p>
<p>By default, every time you do a hardware read, a new command is sent to retrieve it.
Using one command to retrieve ALL the data is bulk reading.</p>
<p>This recipe will not go into the different bulk reading modes. To learn more look <a href="https://gm0.org/en/latest/docs/software/tutorials/bulk-reads.html">here</a>.</p>
<h3 id="caching-motor-powers"><a class="header" href="#caching-motor-powers">Caching Motor Powers</a></h3>
<p>So now let's try and reduce unnecessary hardware writes.</p>
<p>If a motor is going at 0.5 power, and we keep setting the power to 0.5, the output of the motor will not change.
However, each one of those <code>setPower()</code> commands is a hardware write which will delay your loop.
A simple solution to this is to only send a new motor power when it is different from the previous.
The SDK has this built in for this 'exactly equal' case.</p>
<p>However, we can go even further then just difference to remove much more unnecessary writes.
If the motor is currently running at 0.5 power, and you tell it to run at 0.51 power instead, it will have very little effect.
However, it will unnecessarily perform a loop-delaying hardware write.</p>
<p>Instead, you can store the last power sent to a motor and check every new <code>setPower()</code> command to only run if the new power is sufficiently different from the previous power.</p>
<p>Implementations of hardware devices with these optimisations applied are
available <a href="https://github.com/Dairy-Foundation/CachingHardware">here</a>.
This github page provides the installation and usage instructions, so this
recipe won't cover them.</p>
<h3 id="photon"><a class="header" href="#photon">Photon</a></h3>
<p>Photon is another way of increasing loop times.
Photon is an experimental library developed by Eeshwar, an alumni originally from team 7244.
It allows for significantly faster loop times by parallelizing much more of the hardware reads and writes.
Installation instructions for Photon are available <a href="https://github.com/Eeshwar-Krishnan/PhotonFTC">here</a>.</p>
<p>If you have Photon installed, you don't need to use CachingHardware, as Photon
has its own caching hardware. Note that Photon is more advanced than
CachingHardware, so it does the optimisations automatically.</p>
<p>Photon has a few known issues at the moment, here's some troubleshooting steps:</p>
<p><strong>Some people have installed photon and Android Studio does not recognize the <code>@Photon</code> annotation. Instead of <code>implementation 'com.github.Eeshwar-Krishnan:PhotonFTC:v3.0.1-ALPHA'</code>, try <code>implementation 'com.github.Eeshwar-Krishnan:PhotonFTC:main-SNAPSHOT'</code>.</strong></p>
<p><strong>Also, be warned. Photon sometimes when used just randomly reverses motors and servos (but it's always the same ones reversed the same way).</strong></p>
<h3 id="full-examples"><a class="header" href="#full-examples">Full Examples</a></h3>
<p>This example uses <a href="https://github.com/Dairy-Foundation/CachingHardware">CachingHardware</a></p>
<pre><code class="language-java"><span class="boring">package org.firstinspires.ftc.teamcode;
</span><span class="boring">
</span><span class="boring">import com.qualcomm.robotcore.eventloop.opmode.OpMode;
</span><span class="boring">import com.qualcomm.robotcore.hardware.DcMotorEx;
</span><span class="boring">import com.qualcomm.hardware.lynx.LynxModule;
</span><span class="boring">import com.qualcomm.robotcore.util.ElapsedTime;
</span><span class="boring">
</span><span class="boring">import java.util.List;
</span><span class="boring">
</span><span class="boring">import dev.frozenmilk.dairy.cachinghardware.CachingDcMotorEx;
</span><span class="boring">
</span>public class CachingOptimizedOpMode extends OpMode {

	private CachingDcMotorEx exampleMotor;
	private List&lt;LynxModule&gt; allHubs;
	private ElapsedTime elapsedtime;

	@Override
	public void init() {

		elapsedtime = new ElapsedTime();

		// this just sets the bulk reading mode for each hub
		allHubs = hardwareMap.getAll(LynxModule.class);
		for (LynxModule hub : allHubs) {
			hub.setBulkCachingMode(LynxModule.BulkCachingMode.MANUAL);
		}

		exampleMotor = new CachingDcMotorEx(hardwareMap.get(DcMotorEx.class, "example motor"));
		elapsedtime.reset();
	}

	@Override
	public void loop() {
		// clears the cache on each hub
		for (LynxModule hub : allHubs) {
			hub.clearBulkCache();
		}

		// after the first time, it won't actually send new commands
		exampleMotor.setPower(1);

		telemetry.addData("Motor Position", exampleMotor.getCurrentPosition());
		telemetry.addData("Loop Times", elapsedtime.milliseconds());
		elapsedtime.reset();
	}
}

</code></pre>
<p>This example uses <a href="https://github.com/Eeshwar-Krishnan/PhotonFTC">Photon</a></p>
<pre><code class="language-java"><span class="boring">package org.firstinspires.ftc.teamcode;
</span><span class="boring">
</span><span class="boring">import com.qualcomm.robotcore.eventloop.opmode.OpMode;
</span><span class="boring">import com.qualcomm.robotcore.hardware.DcMotorEx;
</span><span class="boring">import com.qualcomm.hardware.lynx.LynxModule;
</span><span class="boring">import com.qualcomm.robotcore.util.ElapsedTime;
</span><span class="boring">
</span><span class="boring">import java.util.List;
</span><span class="boring">
</span><span class="boring">import com.outoftheboxrobotics.photoncore.Photon;
</span><span class="boring">
</span><span class="boring">// note the annotation at the top of the op mode (this is all you have to do to use photon)
</span>@Photon
public class PhotonOptimizedOpMode extends OpMode {

	private DcMotorEx exampleMotor;
	private List&lt;LynxModule&gt; allHubs;
	private ElapsedTime elapsedtime;

	@Override
	public void init() {

		elapsedtime = new ElapsedTime();

		// this just sets the bulk reading mode for each hub
		allHubs = hardwareMap.getAll(LynxModule.class);
		for (LynxModule hub : allHubs) {
			hub.setBulkCachingMode(LynxModule.BulkCachingMode.MANUAL);
		}

		exampleMotor = hardwareMap.get(DcMotorEx.class, "example motor");
		elapsedtime.reset();
	}

	@Override
	public void loop() {
		// clears the cache on each hub
		for (LynxModule hub : allHubs) {
			hub.clearBulkCache();
		}

		// after the first time, it won't actually send new commands
		exampleMotor.setPower(1);

		telemetry.addData("Motor Position", exampleMotor.getCurrentPosition());
		telemetry.addData("Loop Times", elapsedtime.milliseconds());
		elapsedtime.reset();
	}
}

</code></pre>
<p><em>Last Updated: 2024-10-14</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pedro-pathing-vs-road-runner"><a class="header" href="#pedro-pathing-vs-road-runner">Pedro Pathing vs Road Runner</a></h1>
<p><strong>Pedro Pathing</strong> is a recently-created library for autonomous.<br />
It uses a GVF algorithm utilizing BÃ©zier Curves to follow trajectories with speed as a top priority.</p>
<ul>
<li>Docs: https://pedropathing.com</li>
<li>Quickstart: https://github.com/Pedro-Pathing/Quickstart</li>
</ul>
<p><strong>Pros of Pedro</strong></p>
<ul>
<li>Can make your bot drive faster.</li>
<li>Support for recent sensors (OTOS, Pinpoint) is official/built-in.</li>
<li>Excellent correction for unexpected disturbances.</li>
</ul>
<p><strong>Cons of Pedro:</strong></p>
<ul>
<li>Newer, so potentially less stable/buggier.</li>
<li>Fewer people are familiar with it and able to help.</li>
<li>Not necessarily time-consistent.</li>
<li>Uses a nonstandard coordinate system by default/in visualizer.</li>
</ul>
<p><strong>Road Runner</strong> is a motion-profiling-based follower library
that includes a command-based action system and geometry.</p>
<p>It was originally (0.5) created late 2020(?),
with version 1.0 created mid-2023 and last updated 10/13.</p>
<p>It prioritizes time consistency above all else.</p>
<p>Library Repo: <a href="https://github.com/acmerobotics/road-runner/">https://github.com/acmerobotics/road-runner/</a></p>
<p>Quickstart: <a href="https://github.com/acmerobotics/road-runner-quickstart/tree/master/">https://github.com/acmerobotics/road-runner-quickstart/tree/master/</a></p>
<p>Official Docs: <a href="https://rr.brott.dev/docs/v1-0/installation/">https://rr.brott.dev/docs/v1-0/installation/</a></p>
<p><strong>Pros of Road Runner:</strong></p>
<ul>
<li>Stable, minimal bugs if any</li>
<li>Time consistent by default</li>
<li>Extensively tested; used by thousands of teams</li>
<li>Tons of people are able to help you in FTC Discord; someone has almost certainly had your problem before</li>
<li>Lots of projects integrate with it</li>
<li>Uses the FIRST-recommended standard coordinate system consistently</li>
</ul>
<p><strong>Cons of Roadrunner:</strong></p>
<ul>
<li>Prioritizes time consistency above all else, meaning potentially worse correction</li>
<li>Slower speed by default</li>
<li>Support for recent sensors like the SparkFun OTOS and Pinpoint is unofficial
(though still exists, made by j5155)</li>
</ul>
<p>This page is also available on <a href="https://pedropathing.com/misc/pedrovsrr.html">Pedro Docs</a>.
(Note: the Pedro team has updated the version on Pedro docs separately, and we cannot vouch for its accuracy.)</p>
<p><em>Last Updated: 2025-1-5</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">contributors</a></h1>
<ul>
<li>hex <a href="https://github.com/dr-hextanium">(github)</a> <a href="https://discord.com/users/280024224121356288">(discord)</a></li>
<li>0verkil <a href="https://github.com/0verkil">(github)</a> <a href="https://discord.com/users/671902633430089748">(discord)</a></li>
<li>Ruckus Robotics (14712) <a href="https://discord.com/users/292086403926589441">(discord)</a></li>
<li>JL <a href="https://github.com/JoelLee3">(github)</a> <a href="https://discordapp.com/users/760523424635813980">(discord)</a></li>
<li>rjan939 <a href="https://github.com/rjan939">(github)</a> <a href="https://discordapp.com/users/292725814556884995">(discord)</a></li>
<li>Froze 'n' Milk <a href="https://github.com/Froze-N-Milk">(github)</a></li>
<li>Iris <a href="https://github.com/Iris-TheRainbow">(github)</a> <a href="https://discord.com/users/705965203807928381">(discord)</a></li>
<li>j5155 <a href="https://github.com/j5155">(github)</a> <a href="https://discord.com/users/496774369054425109">(discord)</a></li>
<li>Arush <a href="https://github.com/ArushYadlapati">(github)</a> <a href="https://discord.com/users/764258716463529986">(discord)</a></li>
<li>ZachWaffle <a href="https://github.com/zachwaffle4">(github)</a> <a href="https://discord.com/users/522513851942436867">(discord)</a></li>
</ul>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->


                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">

        </nav>

    </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

    <script src="clipboard.min.js"></script>
    <script src="highlight.js"></script>
    <script src="book.js"></script>

    <!-- Cloudflare Web Analytics -->
    <script defer src='https://static.cloudflareinsights.com/beacon.min.js'
            data-cf-beacon='{"token": "6e64e393030545a19896dcac9e462214"}'></script>
    <!-- End Cloudflare Web Analytics -->

    <script defer data-domain="cookbook.dairy.foundation" src="https://plausible.j5155.page/js/script.js"></script>

    <!-- Custom JS scripts -->

            <script>
                window.addEventListener('load', function () {
                    MathJax.Hub.Register.StartupHook('End', function () {
                        window.setTimeout(window.print, 100);
                    });
                });
            </script>

</div>
</body>
</html>
