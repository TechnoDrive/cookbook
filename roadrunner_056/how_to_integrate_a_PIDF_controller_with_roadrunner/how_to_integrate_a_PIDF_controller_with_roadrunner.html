<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>How to integrate a PIDF controller with Road Runner - The Cookbook</title>


    <!-- Custom HTML head -->

    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
    <link rel="stylesheet" href="../../css/variables.css">
    <link rel="stylesheet" href="../../css/general.css">
    <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../../highlight.css">
    <link rel="stylesheet" href="../../tomorrow-night.css">
    <link rel="stylesheet" href="../../ayu-highlight.css">

    <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <!-- Provide site root to javascript -->
    <script>
        var path_to_root = "../../";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>
    <!-- Start loading toc.js asap -->
    <script src="../../toc.js"></script>
</head>
<body>
<div id="body-container">
    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script>
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) {
        }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script>
        var theme;
        try {
            theme = localStorage.getItem('mdbook-theme');
        } catch (e) {
        }
        if (theme === null || theme === undefined) {
            theme = default_theme;
        }
        const html = document.documentElement;
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add("js");
    </script>

    <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

    <!-- Hide / unhide sidebar before it is displayed -->
    <script>
        var sidebar = null;
        var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
        if (document.body.clientWidth >= 1080) {
            try {
                sidebar = localStorage.getItem('mdbook-sidebar');
            } catch (e) {
            }
            sidebar = sidebar || 'visible';
        } else {
            sidebar = 'hidden';
        }
        sidebar_toggle.checked = sidebar === 'visible';
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <!-- populated by js -->
        <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
        <noscript>
            <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
        </noscript>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle">
            <div class="sidebar-resize-indicator"></div>
        </div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky">
                <div class="left-buttons">
                    <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor"
                           title="Toggle Table of Contents" aria-label="Toggle Table of Contents"
                           aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </label>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none">
                            <button role="menuitem" class="theme" id="light">Light</button>
                        </li>
                        <li role="none">
                            <button role="menuitem" class="theme" id="rust">Rust</button>
                        </li>
                        <li role="none">
                            <button role="menuitem" class="theme" id="coal">Coal</button>
                        </li>
                        <li role="none">
                            <button role="menuitem" class="theme" id="navy">Navy</button>
                        </li>
                        <li role="none">
                            <button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                                aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                                aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                </div>

                <h1 class="menu-title">The Cookbook</h1>

                <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/dr-hextanium/cookbook/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/dr-hextanium/cookbook/tree/main/src/roadrunner_056/how_to_integrate_a_PIDF_controller_with_roadrunner/how_to_integrate_a_PIDF_controller_with_roadrunner.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                </div>
            </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                               aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script>
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <h1 id="how-to-integrate-a-pidf-controller-with-roadrunner"><a class="header" href="#how-to-integrate-a-pidf-controller-with-roadrunner">How to Integrate a PIDF Controller With Roadrunner</a></h1>
<p><em>This recipe will assume you have a functioning PIDF controller that has already been tuned. If you do not, refer to <a href="./how_to_integrate_a_PIDF_controller_with_roadrunner.html">integrating a custom PIDF controller</a>.</em></p>
<h2 id="ingredients"><a class="header" href="#ingredients">Ingredients</a></h2>
<ol>
<li>A PID or PIDF controller class</li>
<li>Tuned PID(F) gains</li>
<li>An OpMode or LinearOpMode</li>
<li>A Finite State Machine</li>
</ol>
<h2 id="the-recipe"><a class="header" href="#the-recipe">The Recipe</a></h2>
<h3 id="pidf-controller-and-gains"><a class="header" href="#pidf-controller-and-gains">PID(F) Controller and gains</a></h3>
<p>This recipe assumes you have 1) a PID(F) class that works and 2) tuned PID(F) gains.
This recipe will not go over how to implement these; you should reference <a href="./how_to_integrate_a_PIDF_controller_with_roadrunner.html">integrating a custom PIDF controller</a>.</p>
<h3 id="finite-state-machines"><a class="header" href="#finite-state-machines">Finite State Machines</a></h3>
<p>In short, a finite state machine is a code structure which allows code to run linearly while also having quasi-parallel actions running.
The example we will be working with today is driving with Roadrunner while controlling linear slides.
For a more indepth understanding of what finite state machines are, visit <a href="https://gm0.org/en/latest/docs/software/concepts/finite-state-machines.html?highlight=finite">gm0</a>.</p>
<p>You can work with Finite State Machines in either a LinearOpMode or an OpMode, either work.
For this recipe, we will be using a LinearOpMode.
To use an OpMode, move everything before the while loop into the <code>init()</code> function and everything in the while loop into the <code>loop()</code> function.</p>
<p>We will first have a full example and then break it down piece by piece.</p>
<p><em>This example is more like pseudocode than real code and is meant to demonstrate a methodology.</em></p>
<pre><code class="language-java">public class RoadRunnerPIDF extends LinearOpMode {
    // the capitalization and snake_case is just convention because the values of an enum are constants
    public enum STATES {
        INIT,
        DRIVE_FORWARD,
        STRAFE_LEFT_AND_LIFT_SLIDES,
        DRIVE_BACKWARD,
        STOP;
    }

    private STATES previousState = STATES.INIT;
    private STATES currentState = STATES.INIT;
    private int targetPosition = 0;

    private TrajectorySequence forward;
    private TrajectorySequence strafeLeft;
    private TrajectorySequence backward;

    private SampleMecanumDrive drive;
    private DcMotorEx linearSlides;
    private PIDFController PIDF;

    public void runOpMode() {
        /* for the purpose of this recipe, I will be using linear slides with PIDF control to demonstrate.
        The linear slides will simply be called linearSlides.
        */

        // linear slide initialization code
        // pidf initialization code

        drive = new SampleMecanumDrive(hardwareMap);
        drive.setPoseEstimate(new Pose2d());

        forward = drive.TrajectorySequenceBuilder(new Pose2d())
            .forward(10)
            .build();

        strafeLeft = drive.TrajectorySequenceBuilder(forward.end())
            .addDisplacementMarker(() -&gt; {
                targetPosition = 800;
            })
            .strafeLeft(10)
            .build();

        backward = drive.TrajectorySequenceBuilder(strafeLeft.end())
            .back(10)
            .build();

        waitForStart();

        currentState = STATES.DRIVE_FORWARD;

        while(opModeIsActive) {
            switch (currentState) {
                case (INIT):
                    break;
                case (DRIVE_FORWARD):
                    if (previousState != currentState) {
                        // everything in here will run once when the state switches

                        drive.followTrajectoryAsync(forward)
                        previousState = STATES.DRIVE_FORWARD;
                    } else if (!drive.isBusy()) {
                        currentState = STATES.STRAFE_LEFT_AND_LIFT_SLIDES;
                    }
                    break;
                case (STRAFE_LEFT_AND_LIFT_SLIDES):
                    if (previousState != currentState) {
                        // inside this trajectory sequence the targetPosition is set and the slides will start updating
                        drive.followTrajectorySequenceAsync(strafeLeft);
                    } else if (!drive.isBusy() &amp;&amp; linearSlides.atTarget()) {
                        currentState = STATES.DRIVE_BACKWARD;
                    }
                    break;
                case (DRIVE_BACKWARD):
                    if (previousState != currentState) {
                        drive.followTrajectorySequenceAsync(backward);
                        previousState = STATES.DRIVE_BACKWARD;
                    } else if (!drive.isBusy()) {
                        currentState = STATES.STOP;
                    }
                    break;
                case (STOP):
                    break;
            }

            // outside of the switch we update our slides, that way they are always receiving new information
            drive.update();
            double power = PIDF.calculate(linearSlides.getCurrentPosition(), targetPosition)
            linearSlides.setPower(power);
        }
    }
}
</code></pre>
<p>Okay, let's break this down piece by piece.
First, what is an "enum" and why do we use them?
Enums are a way to define a set of named constant values.
They provide a convenient and readable way to work with predefined, named values in your code.
Here, we used an enum to describe the various states the robot could be in.</p>
<pre><code class="language-java"><span class="boring">public class RoadRunnerPIDF extends LinearOpMode {
</span><span class="boring">    // the capitalization and snake_case is just convention because the values of an enum are constants
</span>    public enum STATES {
        INIT,
        DRIVE_FORWARD,
        STRAFE_LEFT_AND_LIFT_SLIDES,
        DRIVE_BACKWARD,
        STOP;
    }
<span class="boring">
</span><span class="boring">    private STATES previousState = STATES.INIT;
</span><span class="boring">    private STATES currentState = STATES.INIT;
</span><span class="boring">    private int targetPosition = 0;
</span><span class="boring">
</span><span class="boring">    private TrajectorySequence forward;
</span><span class="boring">    private TrajectorySequence strafeLeft;
</span><span class="boring">    private TrajectorySequence backward;
</span><span class="boring">
</span><span class="boring">    private SampleMecanumDrive drive;
</span><span class="boring">    private DcMotorEx linearSlides;
</span><span class="boring">    private PIDFController PIDF;
</span><span class="boring">
</span><span class="boring">    public void runOpMode() {
</span><span class="boring">        /* for the purpose of this recipe, I will be using linear slides with PIDF control to demonstrate.
</span><span class="boring">        The linear slides will simply be called linearSlides.
</span><span class="boring">        */
</span><span class="boring">
</span><span class="boring">        // linear slide initialization code
</span><span class="boring">        // pidf initialization code
</span><span class="boring">
</span><span class="boring">        drive = new SampleMecanumDrive(hardwareMap);
</span><span class="boring">        drive.setPoseEstimate(new Pose2d());
</span><span class="boring">
</span><span class="boring">        forward = drive.TrajectorySequenceBuilder(new Pose2d())
</span><span class="boring">            .forward(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        strafeLeft = drive.TrajectorySequenceBuilder(forward.end())
</span><span class="boring">            .addDisplacementMarker(() -&gt; {
</span><span class="boring">                targetPosition = 800;
</span><span class="boring">            })
</span><span class="boring">            .strafeLeft(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        backward = drive.TrajectorySequenceBuilder(strafeLeft.end())
</span><span class="boring">            .back(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        waitForStart();
</span><span class="boring">
</span><span class="boring">        currentState = STATES.DRIVE_FORWARD;
</span><span class="boring">
</span><span class="boring">        while(opModeIsActive) {
</span><span class="boring">            switch (currentState) {
</span><span class="boring">                case (INIT):
</span><span class="boring">                    break;
</span><span class="boring">                case (DRIVE_FORWARD):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        // everything in here will run once when the state switches
</span><span class="boring">
</span><span class="boring">                        drive.followTrajectoryAsync(forward)
</span><span class="boring">                        previousState = STATES.DRIVE_FORWARD;
</span><span class="boring">                    } else if (!drive.isBusy()) {
</span><span class="boring">                        currentState = STATES.STRAFE_LEFT_AND_LIFT_SLIDES;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (STRAFE_LEFT_AND_LIFT_SLIDES):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        // inside this trajectory sequence the targetPosition is set and the slides will start updating
</span><span class="boring">                        drive.followTrajectorySequenceAsync(strafeLeft);
</span><span class="boring">                    } else if (!drive.isBusy() &amp;&amp; linearSlides.atTarget()) {
</span><span class="boring">                        currentState = STATES.DRIVE_BACKWARD;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (DRIVE_BACKWARD):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        drive.followTrajectorySequenceAsync(backward);
</span><span class="boring">                        previousState = STATES.DRIVE_BACKWARD;
</span><span class="boring">                    } else if (!drive.isBusy()) {
</span><span class="boring">                        currentState = STATES.STOP;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (STOP):
</span><span class="boring">                    break;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            // outside of the switch we update our slides, that way they are always receiving new information
</span><span class="boring">            drive.update();
</span><span class="boring">            double power = PIDF.calculate(linearSlides.getCurrentPosition(), targetPosition)
</span><span class="boring">            linearSlides.setPower(power);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>By using names with meaning like these, it is much clearer when writing and reading the code what each block does.
It also means we don't have to remember that state 0 means START and state 1 means DRIVE_FORWARD, etc.</p>
<p>Next, we initialize everything and build our trajectories.
The important one to note is creating <code>strafeLeft</code>, which includes slide movement.</p>
<pre><code class="language-java"><span class="boring">public class RoadRunnerPIDF extends LinearOpMode {
</span><span class="boring">    // the capitalization and snake_case is just convention because the values of an enum are constants
</span><span class="boring">    public enum STATES {
</span><span class="boring">        INIT,
</span><span class="boring">        DRIVE_FORWARD,
</span><span class="boring">        STRAFE_LEFT_AND_LIFT_SLIDES,
</span><span class="boring">        DRIVE_BACKWARD,
</span><span class="boring">        STOP;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    private STATES previousState = STATES.INIT;
</span><span class="boring">    private STATES currentState = STATES.INIT;
</span><span class="boring">    private int targetPosition = 0;
</span><span class="boring">
</span><span class="boring">    private TrajectorySequence forward;
</span><span class="boring">    private TrajectorySequence strafeLeft;
</span><span class="boring">    private TrajectorySequence backward;
</span><span class="boring">
</span><span class="boring">    private SampleMecanumDrive drive;
</span><span class="boring">    private DcMotorEx linearSlides;
</span><span class="boring">    private PIDFController PIDF;
</span><span class="boring">
</span><span class="boring">    public void runOpMode() {
</span><span class="boring">        /* for the purpose of this recipe, I will be using linear slides with PIDF control to demonstrate.
</span><span class="boring">        The linear slides will simply be called linearSlides.
</span><span class="boring">        */
</span><span class="boring">
</span><span class="boring">        // linear slide initialization code
</span><span class="boring">        // pidf initialization code
</span><span class="boring">
</span><span class="boring">        drive = new SampleMecanumDrive(hardwareMap);
</span><span class="boring">        drive.setPoseEstimate(new Pose2d());
</span><span class="boring">
</span><span class="boring">        forward = drive.TrajectorySequenceBuilder(new Pose2d())
</span><span class="boring">            .forward(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span>        strafeLeft = drive.TrajectorySequenceBuilder(forward.end())
            .addDisplacementMarker(() -&gt; {
                targetPosition = 800;
            })
            .strafeLeft(10)
            .build();
<span class="boring">
</span><span class="boring">        backward = drive.TrajectorySequenceBuilder(strafeLeft.end())
</span><span class="boring">            .back(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        waitForStart();
</span><span class="boring">
</span><span class="boring">        currentState = STATES.DRIVE_FORWARD;
</span><span class="boring">
</span><span class="boring">        while(opModeIsActive) {
</span><span class="boring">            switch (currentState) {
</span><span class="boring">                case (INIT):
</span><span class="boring">                    break;
</span><span class="boring">                case (DRIVE_FORWARD):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        // everything in here will run once when the state switches
</span><span class="boring">
</span><span class="boring">                        drive.followTrajectoryAsync(forward)
</span><span class="boring">                        previousState = STATES.DRIVE_FORWARD;
</span><span class="boring">                    } else if (!drive.isBusy()) {
</span><span class="boring">                        currentState = STATES.STRAFE_LEFT_AND_LIFT_SLIDES;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (STRAFE_LEFT_AND_LIFT_SLIDES):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        // inside this trajectory sequence the targetPosition is set and the slides will start updating
</span><span class="boring">                        drive.followTrajectorySequenceAsync(strafeLeft);
</span><span class="boring">                    } else if (!drive.isBusy() &amp;&amp; linearSlides.atTarget()) {
</span><span class="boring">                        currentState = STATES.DRIVE_BACKWARD;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (DRIVE_BACKWARD):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        drive.followTrajectorySequenceAsync(backward);
</span><span class="boring">                        previousState = STATES.DRIVE_BACKWARD;
</span><span class="boring">                    } else if (!drive.isBusy()) {
</span><span class="boring">                        currentState = STATES.STOP;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (STOP):
</span><span class="boring">                    break;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            // outside of the switch we update our slides, that way they are always receiving new information
</span><span class="boring">            drive.update();
</span><span class="boring">            double power = PIDF.calculate(linearSlides.getCurrentPosition(), targetPosition)
</span><span class="boring">            linearSlides.setPower(power);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We used a displacement marker, which tells Roadrunner to run this code at the specified position along the trajectory.
The <code>() -&gt; {}</code> is the lambda format for a one time use function.
The empty parentheses indicate that the function requires no arguments, and the curly braces denote the start of the function.
In this case, we're just setting the <code>targetPosition</code> variable, but this marker could include setting servo position, reading sensors, or anything else really.</p>
<pre><code class="language-java"><span class="boring">public class RoadRunnerPIDF extends LinearOpMode {
</span><span class="boring">    // the capitalization and snake_case is just convention because the values of an enum are constants
</span><span class="boring">    public enum STATES {
</span><span class="boring">        INIT,
</span><span class="boring">        DRIVE_FORWARD,
</span><span class="boring">        STRAFE_LEFT_AND_LIFT_SLIDES,
</span><span class="boring">        DRIVE_BACKWARD,
</span><span class="boring">        STOP;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    private STATES previousState = STATES.INIT;
</span><span class="boring">    private STATES currentState = STATES.INIT;
</span><span class="boring">    private int targetPosition = 0;
</span><span class="boring">
</span><span class="boring">    private TrajectorySequence forward;
</span><span class="boring">    private TrajectorySequence strafeLeft;
</span><span class="boring">    private TrajectorySequence backward;
</span><span class="boring">
</span><span class="boring">    private SampleMecanumDrive drive;
</span><span class="boring">    private DcMotorEx linearSlides;
</span><span class="boring">    private PIDFController PIDF;
</span><span class="boring">
</span><span class="boring">    public void runOpMode() {
</span><span class="boring">        /* for the purpose of this recipe, I will be using linear slides with PIDF control to demonstrate.
</span><span class="boring">        The linear slides will simply be called linearSlides.
</span><span class="boring">        */
</span><span class="boring">
</span><span class="boring">        // linear slide initialization code
</span><span class="boring">        // pidf initialization code
</span><span class="boring">
</span><span class="boring">        drive = new SampleMecanumDrive(hardwareMap);
</span><span class="boring">        drive.setPoseEstimate(new Pose2d());
</span><span class="boring">
</span><span class="boring">        forward = drive.TrajectorySequenceBuilder(new Pose2d())
</span><span class="boring">            .forward(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        strafeLeft = drive.TrajectorySequenceBuilder(forward.end())
</span><span class="boring">            .addDisplacementMarker(() -&gt; {
</span><span class="boring">                targetPosition = 800;
</span><span class="boring">            })
</span><span class="boring">            .strafeLeft(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        backward = drive.TrajectorySequenceBuilder(strafeLeft.end())
</span><span class="boring">            .back(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        waitForStart();
</span><span class="boring">
</span><span class="boring">        currentState = STATES.DRIVE_FORWARD;
</span><span class="boring">
</span><span class="boring">        while(opModeIsActive) {
</span><span class="boring">            switch (currentState) {
</span><span class="boring">                case (INIT):
</span><span class="boring">                    break;
</span>                case (DRIVE_FORWARD):
                    if (previousState != currentState) {
                        // everything in here will run once when the state switches

                        drive.followTrajectoryAsync(forward)
                        previousState = STATES.DRIVE_FORWARD;
                    } else if (!drive.isBusy()) {
                        currentState = STATES.STRAFE_LEFT_AND_LIFT_SLIDES;
                    }
                    break;
<span class="boring">                case (STRAFE_LEFT_AND_LIFT_SLIDES):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        // inside this trajectory sequence the targetPosition is set and the slides will start updating
</span><span class="boring">                        drive.followTrajectorySequenceAsync(strafeLeft);
</span><span class="boring">                    } else if (!drive.isBusy() &amp;&amp; linearSlides.atTarget()) {
</span><span class="boring">                        currentState = STATES.DRIVE_BACKWARD;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (DRIVE_BACKWARD):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        drive.followTrajectorySequenceAsync(backward);
</span><span class="boring">                        previousState = STATES.DRIVE_BACKWARD;
</span><span class="boring">                    } else if (!drive.isBusy()) {
</span><span class="boring">                        currentState = STATES.STOP;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (STOP):
</span><span class="boring">                    break;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            // outside of the switch we update our slides, that way they are always receiving new information
</span><span class="boring">            drive.update();
</span><span class="boring">            double power = PIDF.calculate(linearSlides.getCurrentPosition(), targetPosition)
</span><span class="boring">            linearSlides.setPower(power);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>So now we're getting to the Finite State Machine (FSM) part.
The first part of this case, which you'll see in each part, is checking whether previous and current states are equal.
This allows us to run code the first time it enters this state, like starting a trajectory (in this example).
Then inside that same block, we also need to set the previous state to the one we're in.</p>
<p>The <code>else if</code> just checks if we're done with this state to detect when to move on.
This is the transition trigger.
In this case, it detects when the Roadrunner trajectory finishes.</p>
<p>The next case is the more interesting one.</p>
<pre><code class="language-java"><span class="boring">public class RoadRunnerPIDF extends LinearOpMode {
</span><span class="boring">    // the capitalization and snake_case is just convention because the values of an enum are constants
</span><span class="boring">    public enum STATES {
</span><span class="boring">        INIT,
</span><span class="boring">        DRIVE_FORWARD,
</span><span class="boring">        STRAFE_LEFT_AND_LIFT_SLIDES,
</span><span class="boring">        DRIVE_BACKWARD,
</span><span class="boring">        STOP;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    private STATES previousState = STATES.INIT;
</span><span class="boring">    private STATES currentState = STATES.INIT;
</span><span class="boring">    private int targetPosition = 0;
</span><span class="boring">
</span><span class="boring">    private TrajectorySequence forward;
</span><span class="boring">    private TrajectorySequence strafeLeft;
</span><span class="boring">    private TrajectorySequence backward;
</span><span class="boring">
</span><span class="boring">    private SampleMecanumDrive drive;
</span><span class="boring">    private DcMotorEx linearSlides;
</span><span class="boring">    private PIDFController PIDF;
</span><span class="boring">
</span><span class="boring">    public void runOpMode() {
</span><span class="boring">        /* for the purpose of this recipe, I will be using linear slides with PIDF control to demonstrate.
</span><span class="boring">        The linear slides will simply be called linearSlides.
</span><span class="boring">        */
</span><span class="boring">
</span><span class="boring">        // linear slide initialization code
</span><span class="boring">        // pidf initialization code
</span><span class="boring">
</span><span class="boring">        drive = new SampleMecanumDrive(hardwareMap);
</span><span class="boring">        drive.setPoseEstimate(new Pose2d());
</span><span class="boring">
</span><span class="boring">        forward = drive.TrajectorySequenceBuilder(new Pose2d())
</span><span class="boring">            .forward(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        strafeLeft = drive.TrajectorySequenceBuilder(forward.end())
</span><span class="boring">            .addDisplacementMarker(() -&gt; {
</span><span class="boring">                targetPosition = 800;
</span><span class="boring">            })
</span><span class="boring">            .strafeLeft(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        backward = drive.TrajectorySequenceBuilder(strafeLeft.end())
</span><span class="boring">            .back(10)
</span><span class="boring">            .build();
</span><span class="boring">
</span><span class="boring">        waitForStart();
</span><span class="boring">
</span><span class="boring">        currentState = STATES.DRIVE_FORWARD;
</span><span class="boring">
</span><span class="boring">        while(opModeIsActive) {
</span><span class="boring">            switch (currentState) {
</span><span class="boring">                case (INIT):
</span><span class="boring">                    break;
</span><span class="boring">                case (DRIVE_FORWARD):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        // everything in here will run once when the state switches
</span><span class="boring">
</span><span class="boring">                        drive.followTrajectoryAsync(forward)
</span><span class="boring">                        previousState = STATES.DRIVE_FORWARD;
</span><span class="boring">                    } else if (!drive.isBusy()) {
</span><span class="boring">                        currentState = STATES.STRAFE_LEFT_AND_LIFT_SLIDES;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span>                case (STRAFE_LEFT_AND_LIFT_SLIDES):
                    if (previousState != currentState) {
                        // inside this trajectory sequence the targetPosition is set and the slides will start updating
                        drive.followTrajectorySequenceAsync(strafeLeft);
                    } else if (!drive.isBusy() &amp;&amp; linearSlides.atTarget()) {
                        currentState = STATES.DRIVE_BACKWARD;
                    }
                    break;
<span class="boring">                case (DRIVE_BACKWARD):
</span><span class="boring">                    if (previousState != currentState) {
</span><span class="boring">                        drive.followTrajectorySequenceAsync(backward);
</span><span class="boring">                        previousState = STATES.DRIVE_BACKWARD;
</span><span class="boring">                    } else if (!drive.isBusy()) {
</span><span class="boring">                        currentState = STATES.STOP;
</span><span class="boring">                    }
</span><span class="boring">                    break;
</span><span class="boring">                case (STOP):
</span><span class="boring">                    break;
</span><span class="boring">            }
</span><span class="boring">
</span><span class="boring">            // outside of the switch we update our slides, that way they are always receiving new information
</span><span class="boring">            drive.update();
</span><span class="boring">            double power = PIDF.calculate(linearSlides.getCurrentPosition(), targetPosition)
</span><span class="boring">            linearSlides.setPower(power);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Here we have the same structure.
However, this time our transition trigger is finishing the Roadrunner trajectory and the linear slides reaching their target.
Because this runs in a loop, once the displacement marker triggers and changes the targetPosition, the PID update that runs at the end of every loop will move the linear slides accordingly.</p>
<p>It is also important to note that when using async following, you must call drive.update() once every loop.
This allows Roadrunner to track the robot's movement and to ensure the motors are following the trajectory.
Without it, the robot will not move.</p>
<p>Whew! You should now be able to integrate a PID(F) controller with Roadrunner trajectories.</p>
<p>This example was meant to be general and explain the structure and concepts needed to make PID(F) controllers work with Roadrunner.
It will almost certainly require changes to make it work exactly how you wish, so don't worry if your code doesn't look exactly like this example!</p>
<h3 id="state-factory"><a class="header" href="#state-factory">State Factory</a></h3>
<p><a href="https://state-factory.gitbook.io/state-factory/installation">State Factory</a> is a library which helps abstract a lot of the code of a finite state machine.
It also helps ensure you don't forget to write a break or an exit case.</p>
<p><em>This recipe will not cover the installation of State Factory.
Please follow the instructions on their gitbook to install it.</em></p>
<p>So, we're going to write the same finite state machine but this time using State Factory.</p>
<pre><code class="language-java">public class RoadRunnerPIDFSF extends LinearOpMode {

    public enum STATES {
        INIT,
        DRIVE_FORWARD,
        STRAFE_LEFT_AND_LIFT_SLIDES,
        DRIVE_BACKWARD,
        STOP;
    }

    SampleMecanumDrive drive;
    DcMotorEx linearSlides;
    PIDFController PIDF;
    int targetPosition = 0;

    public void runOpMode() {

        // all the same initialization and trajectory building as above

        StateMachine machine = new StateMachine()
            .state(STATES.INIT) // creates a new state
            .transition(() -&gt; isStarted()) // condition to transition from this state to the next one

            .state(STATES.DRIVE_FORWARD) // register a new state
            .onEnter(() -&gt; drive.followTrajectorySequenceAsync(forward)) // code to happen one time when entering this state
            .transition(() -&gt; !drive.isBusy())

            .state(STATES.STRAFE_LEFT_AND_LIFT_SLIDES)
            .onEnter(() -&gt; drive.followTrajectorySequenceAsync(strafeLeft))
            .transition(() -&gt; (!drive.isBusy() &amp;&amp; linearSlides.atTarget()))

            .state(STATES.DRIVE_BACKWARD)
            .onEnter(() -&gt; drive.followTrajectorySequenceAsync(backward))
            .transition(() -&gt; !drive.isBusy())

            .state(STATES.STOP)

            .build();
        // building this StateMachine doesn't actually do anything. We still need to run it

        waitForStart();

        machine.start(); // this starts the state machine, putting us into the first state

        while(opModeIsActive()) {
            machine.update();
            drive.update();
            double power = PIDF(linearSlides.getCurrentPosition(), targetPosition);
            linearSlides.setPower(power);
        }
    }
}
</code></pre>
<p>These two examples both do the exact same thing.
This introduction to State Factory was mostly meant to show how it can simplify writing FSMs.</p>
<p>Android studio may recommend changing something like <code>() -&gt; !drive.isBusy()</code> to <code>!drive::isBusy</code>.
These are simply two different ways to write the same thing.
The double colon works like <code>class/instance::method</code>.</p>
<p><strong>It is important to note that these were extremely simple FSMs and do not demonstrate their full capabilities.
This was simply meant to show you a way to integrate RoadRunner and a PIDF controller.</strong></p>
<p><em>Last Updated: 2024-01-23</em></p>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                        <a rel="prev" href="../../roadrunner_056/robot_drives_full_speed_on_start_when_following_trajectory.html" class="mobile-nav-chapters previous"
                           title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a rel="next prefetch" href="../../common_ds_errors/npe_at_init/npe_at_init.html" class="mobile-nav-chapters next"
                           title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a rel="prev" href="../../roadrunner_056/robot_drives_full_speed_on_start_when_following_trajectory.html" class="nav-chapters previous" title="Previous chapter"
                   aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a rel="next prefetch" href="../../common_ds_errors/npe_at_init/npe_at_init.html" class="nav-chapters next" title="Next chapter"
                   aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
        </nav>

    </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

    <script src="../../clipboard.min.js"></script>
    <script src="../../highlight.js"></script>
    <script src="../../book.js"></script>

    <!-- Cloudflare Web Analytics -->
    <script defer src='https://static.cloudflareinsights.com/beacon.min.js'
            data-cf-beacon='{"token": "6e64e393030545a19896dcac9e462214"}'></script>
    <!-- End Cloudflare Web Analytics -->

    <script defer data-domain="cookbook.dairy.foundation" src="https://plausible.j5155.page/js/script.js"></script>

    <!-- Custom JS scripts -->


</div>
</body>
</html>
